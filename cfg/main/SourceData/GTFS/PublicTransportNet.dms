container PublicTransportNet : using = "geometries;sourcedata/regioindelingen"
{
	unit<uint32> Routes := StudyAreaFeeds/Routes;
	unit<uint32> Stops  := StudyAreaFeeds/Stops
	{
		attribute<Time>       FirstEvent            := min(ScheduledSpaceTimeEvents/Time_rel, ScheduledSpaceTimeEvents/Stop_rel);
		attribute<Time>       LastEvent             := max(ScheduledSpaceTimeEvents/Time_rel, ScheduledSpaceTimeEvents/Stop_rel);
		attribute<uint32>     TotalScheduledEvents  := pcount(ScheduledSpaceTimeEvents/Stop_rel);
		attribute<Places>     Place_rel             := rlookup(geometry, Places/geometry);
	}
		
	unit<uint32> Places          := allLinks/Places;
	unit<uint32> AllTimes        := allLinks/UniqueTimeEvents;
	
	unit<uint32> ScheduledLinks  := StudyAreaFeeds/ScheduledLinks 
	{
		attribute<ScheduledSpaceTimeEvents> from_sst   := rlookup(point_xy(depTime, fromStop, upoint), ScheduledSpaceTimeEvents/Values);
		attribute<ScheduledSpaceTimeEvents> to_sst     := rlookup(point_xy(arrTime, toStop, upoint), ScheduledSpaceTimeEvents/Values);
		attribute<s_f>                      Duration   := depTime <= arrTime 
															? float32(sub_or_null(arrTime,depTime))[s_f]
															: float32(sub_or_null(arrTime + #Time, depTime))[s_f];
		attribute<string>                   Label  := 'Scheduled: ' + Time/Label[depTime] + ' @ ' + Stops/Name[fromStop] + ' to ' + Time/Label[arrTime] + ' @ ' + Stops/Name[toStop];
		
		unit<uint32> findUniqueSpaceTimeEvents := union_unit(ScheduledLinks, ScheduledLinks)
		{
			attribute<upoint> timesOfStop  := union_data(., point_xy(ScheduledLinks/depTime, ScheduledLinks/fromStop), point_xy(ScheduledLinks/arrTime, ScheduledLinks/toStop));
			attribute<Time>   Time_rel      := pointCol(timesOfStop);
		}
		attribute<rdc>                     fromPoint       := first_point(geometry);
		attribute<rdc>                     toPoint         := last_point(geometry);
		attribute<Places>                  FromPlace_rel   := rlookup(fromPoint, Places/geometry);
		attribute<Places>                  ToPlace_rel     := rlookup(toPoint, Places/geometry);
		attribute<Stops>                   FromStop_rel    := Places/Stop_rel[FromPlace_rel];
		attribute<Stops>                   ToStop_rel      := Places/Stop_rel[ToPlace_rel];
		
		attribute<Concessiegebied>         Start_Concessiegebied_rel      := point_in_polygon(Stops/geometry[FromStop_rel], Concessiegebied/geometry);
		attribute<string>                  Mode_Agency_CG_Lijn_identifier := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel] + '_' + RouteName_short;
		attribute<string>                  Mode_Agency_CG_identifier      := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel];
		attribute<string>                  Mode_Agency_identifier         := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel];
		
		attribute<bool>                    IsForeign  := Agencies/IsForeign[Agency_rel];
		attribute<bool>                    IsDomestic := NOT(IsForeign);
		
		attribute<PrijsTabel>    PrijsTabel_rel_initial        := rlookup(Mode_Agency_CG_Lijn_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented1     := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented2     := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		attribute<PrijsTabel>    PrijsTabel_rel_augmentation   := MakeDefined(PrijsTabel_rel_augmented1, PrijsTabel_rel_augmented2);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev1 := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_identifier);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev2 := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_identifier);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev  := MakeDefined(PrijsTabel_rel_augmented_rev1, PrijsTabel_rel_augmented_rev2);
		attribute<PrijsTabel>    PrijsTabel_rel_augmented      := MakeDefined(PrijsTabel_rel_augmentation, PrijsTabel_rel_augmented_rev);
		attribute<PrijsTabel>    PrijsTabel_rel                := MakeDefined(PrijsTabel_rel_initial, PrijsTabel_rel_augmented);
		
		attribute<bool>          HasPriceRelation              := IsForeign || IsDefined(PrijsTabel_rel) && IsDomestic;
		
		unit<uint8> PrijsTabel := /SourceData/Infrastructuur/OVprijzen/PrijsTabel;
		
		unit<uint32> HasNoPriceRelation := select_with_org_rel_with_attr_by_cond(.,NOT(HasPriceRelation))
		{
			attribute<rdc>                       geometry (arc)         := ../geometry[org_rel];
			attribute<Agencies>                  Agency_rel             := ../Agency_rel[org_rel];
			attribute<GTFS_Modes/Selectie>   Mode_rel               := ../Mode_rel[org_rel];
		}
	}
	
	// unit<uint32> ScheduledTimeEvents      := unique(ScheduledLinks/findUniqueSpaceTimeEvents/Time_rel);
	
	unit<uint32> ScheduledSpaceTimeEvents := unique(ScheduledLinks/findUniqueSpaceTimeEvents/TimesOfStop)
	, Descr = "aka SSTE"
	{
		attribute<Stops>    Stop_rel         := pointRow(Values)[Stops];
		attribute<Time>     Time_rel         := pointCol(Values)[Time];
		attribute<string>   Label           := Stops/Name[Stop_rel] + ' @ ' + Time/Label[Time_rel];
		attribute<.>        FirstMoment     := min_index(Time_rel, Stop_rel)[Stop_rel];
		attribute<.>        NextMoment      := Stop_rel[id(.)+1] = Stop_rel ? id(.) + 1 : FirstMoment;
		attribute<bool>     points_unsorted := Values != sort(Values); // check to verify Values are orderd ascendingly (documented as such in online documentation)
		attribute<uint32>   cumu_events_Stop:= cumulate(const(1,.,uint32), Stop_rel) - 1;
		attribute<upoint>   unique_id       := point_xy(cumu_events_Stop, Stop_rel, upoint);
		
		attribute<uint32>   aantal_tijden_per_stop := pcount(Stop_rel)[Stop_rel];
	}
	
	container CreateTransfersSet 
	{
		// unit<uint32> TransferFromStops := select_with_attr_by_org_rel(Stops, Stops/nTransfers > 0)
		unit<uint32> TransferFromStops := select_with_org_rel(Stops/nTransfers > 0)
		{
			attribute<rdc>       geometry       := Stops/geometry[org_rel];
			attribute<uint32>    nTransfers     := Stops/nTransfers[org_rel];
			attribute<string>    Label          := Stops/Label[org_rel];
			attribute<StopsGrid> GridId         := Stops/GridId[org_rel];
			attribute<uint32>    Grid1D         := Stops/Grid1D[org_rel];
			attribute<uint32>    cumu_in_grid   := Stops/cumu_in_grid[org_rel];
			attribute<upoint>    unique_id      := Stops/unique_id[org_rel];
			attribute<uint32>    first_transfer := cumulate(nTransfers) - nTransfers;
			attribute<uint32>    nEvents        := pcount(ScheduledSpaceTimeEvents/Stop_rel)[org_rel];
			attribute<GTFS_Modes/Selectie> Mode_rel      := Stops/Mode_rel[org_rel];
		}
		
		unit<spoint> StopsGrid := Stops/StopsGrid;
		
		unit<uint32> Directions: NrOfRows = 5 
		{
			attribute<string> Label    : ['Top', 'Right', 'Bottom', 'Left', 'Centre'];
			attribute<int16>  row      : [0,1,0,-1,0];
			attribute<int16>  col      : [1,0,-1,0,0];
			attribute<spoint> geometry := point_xy(row,col, spoint);
		}
		
		unit<uint32> TransferPaths := range(uint32, 0, sum(TransferFromStops/nTransfers))
		{
			attribute<TransferFromStops>   first_from_stop     := rlookup(id(.), TransferFromStops/first_transfer);
			attribute<TransferFromStops>   from_trans_Stop_rel := cumulate(uint32(IsDefined(first_from_stop))) - 1;
			attribute<Stops>               from_Stop_rel       := TransferFromStops/org_rel[from_trans_Stop_rel];
			attribute<GTFS_Modes/Selectie> from_Mode           := TransferFromStops/Mode_rel[from_trans_Stop_rel];
			attribute<GTFS_Modes/Selectie> to_Mode             := Stops/Mode_rel[to_Stop_rel];
			
			attribute<bool>               NeedsTranferTimePenalty := GTFS_Modes/Selectie/IsGelijkvloers[from_Mode] == 1b && GTFS_Modes/Selectie/IsGelijkvloers[to_Mode] == 1b //van: bus, tram, walk    to bus, tram, walk  --> niks
																		? False
																		: GTFS_Modes/Selectie/IsGelijkvloers[from_Mode] == 1b && GTFS_Modes/Selectie/IsGelijkvloers[to_Mode] == 0b //van: bus, tram, walk to metro, rail, ferry --> penalty
																			? TRUE
																			: GTFS_Modes/Selectie/IsGelijkvloers[from_Mode] == 0b && GTFS_Modes/Selectie/IsGelijkvloers[to_Mode] == 0b //van: metro, rail, ferry to metro, rail, ferry --> penalty
																				? TRUE
																				: GTFS_Modes/Selectie/IsGelijkvloers[from_Mode] == 0b && GTFS_Modes/Selectie/IsGelijkvloers[to_Mode] == 1b //van: metro, rail, ferry to bus, tram, walk --> penalty
																					? TRUE
																					: (0/0)[bool];

			attribute<uint32>             nEvents            := pcount(ScheduledSpaceTimeEvents/Stop_rel)[from_Stop_rel];
			attribute<uint32>             first_trans_event  := cumulate(nEvents) - nEvents;
			attribute<upoint>             from_unique_id     := Stops/Unique_id[from_Stop_rel];
			attribute<StopsGrid>          from_StopsGrid_rel := Stops/StopsGrid_rel[from_Stop_rel];
			attribute<uint32>             nTop               := StopsGrid/nTop[from_StopsGrid_rel];
			attribute<uint32>             nRight             := StopsGrid/nRight[from_StopsGrid_rel];
			attribute<uint32>             nBottom            := StopsGrid/nBottom[from_StopsGrid_rel];
			attribute<uint32>             nLeft              := StopsGrid/nLeft[from_StopsGrid_rel];
			attribute<uint32>             first_trans        := TransferFromStops/first_transfer[from_trans_Stop_rel];
 
			attribute<Directions>         quad               := switch( //top, right, bottom, left, middle
																	 case(nTop > 0   	&& nTop    > (sub_or_null(id(.),first_trans)), uint32(0)) 
																	,case(nRight > 0 	&& nRight  > (sub_or_null(id(.),(first_trans + nTop))), uint32(1))
																	,case(nBottom > 0 	&& nBottom > (sub_or_null(id(.),(first_trans + nRight + nTop))), uint32(2))
																	,case(nLeft > 0 	&& nLeft   > (sub_or_null(id(.),(first_trans + nBottom + nRight + nTop))), uint32(3)) 
																	,4
																)[Directions];
																
			attribute<StopsGrid>          to_StopsGrid_rel          := (spoint(from_StopsGrid_rel) + Directions/geometry[quad])[StopsGrid];
			attribute<uint32>             to_StopsGrid_id          := StopsGrid/id[to_StopsGrid_rel];
			attribute<upoint>             to_unique_id       := point_xy(seq2, to_StopsGrid_id, upoint);
			attribute<Stops>              to_Stop_rel         := rlookup(to_unique_id, Stops/unique_id);
				
			attribute<uint32>             seq1               := id(.) 
																	- switch(
																		case(quad = 0, first_trans)
																		, case(quad = 1, first_trans + nTop)
																		, case(quad = 2, first_trans + nTop + nRight)
																		, case(quad = 3, first_trans + nTop + nRight + nBottom)
																		, first_trans + nTop + nRight + nBottom + nLeft
																	);
			attribute<uint32>             seq2               := quad = 4 && seq1 >= Stops/CumulateStop_in_grid[from_Stop_rel] ? seq1 + 1 : seq1;
			
			attribute<string>             Label              := 'Transfer from ' + Stops/Label[from_Stop_rel] + ' to ' + Stops/Label[to_Stop_rel];
			attribute<rdc>                geometry (arc)     := points2sequence(GenLines/Points,GenLines/Seq,GenLines/Ord);
			attribute<m>                  Distance           := arc_length(geometry, m);
			attribute<s_f>                minTransferTime    := Distance / ModelParameters/Advanced/TransferEffectiveSpeed;
			
			unit<uint32> GenLines:= union_unit(TransferPaths, TransferPaths)
			{
				attribute<rdc>              Points := union_data(., Stops/geometry[from_Stop_rel], Stops/geometry[to_Stop_rel]);
				attribute<TransferPaths>    Seq    := union_data(., id(TransferPaths), id(TransferPaths));
				attribute<uint32>           Ord    := union_data(., const(0,TransferPaths,uint32), const(1,TransferPaths,uint32));
			}
		}
		unit<uint32> TransfersByStart := range(uint32, 0, sum(TransferPaths/nEvents))
		{
			attribute<TransferPaths>            first_TransferPath      := rlookup(id(.), TransferPaths/first_trans_event);
			attribute<TransferPaths>            TransferPath_rel        := cumulate(uint32(IsDefined(first_TransferPath))) - 1;
			attribute<rdc>                      geometry (arc)          := TransferPaths/geometry[TransferPath_rel];
			attribute<Stops>                    fromStop_rel            := TransferPaths/from_Stop_rel[TransferPath_rel];
			attribute<Stops>                    toStop_rel              := TransferPaths/to_Stop_rel[TransferPath_rel];
			attribute<bool>                     NeedsTranferTimePenalty := TransferPaths/NeedsTranferTimePenalty[TransferPath_rel];
			attribute<uint32>                   cumu_events             := cumulate(const(1,.,uint32), TransferPath_rel) - 1;
			attribute<ScheduledSpaceTimeEvents> SSTE_rel                := rlookup(point_xy(cumu_events, fromStop_rel, upoint), ScheduledSpaceTimeEvents/unique_id);
			attribute<Time>                     fromTime                := ScheduledSpaceTimeEvents/Time_rel[SSTE_rel];
			attribute<s_f>                      Duration                := NeedsTranferTimePenalty ? TransferPaths/minTransferTime[TransferPath_rel] + convert(ModelParameters/OngelijkvloersPenalty, s_f) : TransferPaths/minTransferTime[TransferPath_rel];
			attribute<Time>                     toTime                  := fromTime + Duration[Time] < #Time 
																				? fromTime + Duration[Time] 
																				: sub_or_null(fromTime + Duration[Time],#Time);
			attribute<string>                   Label                   := 'Transfer: ' + Time/Label[fromTime] + ' @ ' + Stops/Name[fromStop_rel] + ' to ' + Time/Label[toTime] + ' @ ' + Stops/Name[toStop_rel], DialogType = "LabelText";
		}
	}
	
	unit<uint32> allLinks := union_unit(ScheduledLinks, CreateTransfersSet/TransfersByStart)
	, Descr = "scheduled links + transfer links"
	{
		attribute<rdc>                     geometry (arc)  := union_data(., ScheduledLinks/geometry, CreateTransfersSet/TransfersByStart/geometry); 
		attribute<Time>                    fromTime        := union_data(., ScheduledLinks/depTime, CreateTransfersSet/TransfersByStart/fromTime); 
		attribute<Time>                    toTime          := union_data(., ScheduledLinks/arrTime, CreateTransfersSet/TransfersByStart/toTime); 
		attribute<s_f>                     Duration        := union_data(., ScheduledLinks/Duration, CreateTransfersSet/TransfersByStart/Duration); 
		attribute<string>                  Label           := union_data(., ScheduledLinks/Label, CreateTransfersSet/TransfersByStart/Label), DialogType = "LabelText";
		attribute<Trips>                   Trip_rel        := union_data(., ScheduledLinks/Trip_rel, const(0/0,CreateTransfersSet/TransfersByStart));
		attribute<Routes>                  Route_rel       := union_data(., ScheduledLinks/Route_rel, const((0/0)[Routes],CreateTransfersSet/TransfersByStart));
		attribute<string>                  RouteName       := union_data(., ScheduledLinks/RouteName, const('Walking',CreateTransfersSet/TransfersByStart));
		attribute<string>                  RouteName_short := union_data(., ScheduledLinks/RouteName_short, const('Walking',CreateTransfersSet/TransfersByStart));
		attribute<Agencies>                Agency_rel      := union_data(., ScheduledLinks/Agency_rel, const(0/0,CreateTransfersSet/TransfersByStart));
		attribute<GTFS_Modes/Selectie>     Mode_rel        := union_data(., ScheduledLinks/Mode_rel, const(GTFS_Modes/Selectie/V/Walking, CreateTransfersSet/TransfersByStart, GTFS_Modes/Selectie));
		attribute<LinkTypes>               LinkType        := union_data(., const(LinkTypes/V/Scheduled,ScheduledLinks,LinkTypes), const(LinkTypes/V/Transfer,CreateTransfersSet/TransfersByStart,LinkTypes));
		attribute<rdc>                     fromPoint       := first_point(geometry);
		attribute<rdc>                     toPoint         := last_point(geometry);
		attribute<Places>                  FromPlace       := rlookup(fromPoint, Places/Values);
		attribute<string>                  FromPlace_name  := Places/Stop_name[FromPlace];
		attribute<Places>                  ToPlace         := rlookup(toPoint, Places/Values);
		attribute<string>                  ToPlace_name    := Places/Stop_name[ToPlace];
		
		unit<uint32> doubledLinks := union_unit(allLinks, allLinks)
		, Descr = "in order to get a set of all time-place events"
		{
			attribute<Time>     Moment         := union_data(., fromTime, toTime);
			attribute<rdc>      geometry       := union_data(., fromPoint, toPoint);
			attribute<Stops>    Stop_rel       := rlookup(geometry, Stops/geometry);
			attribute<Places>   Place_rel      := rlookup(geometry, Places/geometry);
			attribute<upoint>   MomentxPlace   := point_xy(Moment, Place_rel, upoint);
			attribute<upoint>   MomentxStop    := point_xy(Moment, Stop_rel, upoint);
		}
		
		unit<uint32> Places := unique(doubledLinks/geometry)
		, Descr = "unique stop locations"
		{
			attribute<Stops>   Stop_rel    := rlookup(geometry, Stops/geometry);
			attribute<string>  Stop_name   := Stops/Name[Stop_rel];
			attribute<string>  Label       := Stop_name;
			attribute<rdc>     geometry    := values;
		}
		
		unit<uint32> UniqueTimeEvents   := unique(doubledLinks/Moment);
		unit<uint32> UniqueMomentXStop  := unique(doubledLinks/MomentxStop)
		{
			attribute<upoint>   MomentxStop        := values;
			attribute<Stops>    Stop_rel           := pointRow(MomentxStop)[Stops];
			attribute<Time>     Time_rel           := pointCol(MomentxStop)[Time];
			attribute<string>   Label              := Stops/Name[Stop_rel] + ' @ ' + Time/Label[Time_rel];
			attribute<.>        FirstMoment        := min_index(Time_rel, Stop_rel)[Stop_rel];
			attribute<.>        NextMoment         := Stop_rel[add_or_null(id(.),1)] = Stop_rel ? add_or_null(id(.),1) : FirstMoment;
			attribute<bool>     points_unsorted    := Values != sort(Values); // check to verify Values are orderd ascendingly (documented as such in online documentation)
			
			unit<uint32>  MakeWaitingLines := union_unit(UniqueMomentXStop, UniqueMomentXStop)
			{
				attribute<rdc>                      geometry     := union_data(., Stops/geometry[Stop_rel], Stops/geometry[Stop_rel]);
				attribute<UniqueMomentXStop>        sequence_rel := union_data(., id(UniqueMomentXStop), id(UniqueMomentXStop));
				attribute<uint32>                   ordinal      := union_data(., const(0,UniqueMomentXStop,uint32), const(1,UniqueMomentXStop,uint32));
			}
		}
		unit<uint32> WaitingAtStop := UniqueMomentXStop 
		{
			attribute<rdc>          geometry (arc) := points2sequence(UniqueMomentXStop/MakeWaitingLines/geometry, UniqueMomentXStop/MakeWaitingLines/sequence_rel, UniqueMomentXStop/MakeWaitingLines/ordinal);
			attribute<Stops>        FromStop_rel   := Stop_rel;
			attribute<Stops>        ToStop_rel     := Stop_rel[NextMoment];
			attribute<Places>       FromPlace_rel  := Stops/Place_rel[FromStop_rel];
			attribute<string>       FromPlace_name := Stops/name[FromStop_rel];
			attribute<string>       ToPlace_name   := Stops/name[ToStop_rel];
			attribute<Places>       ToPlace_rel    := Stops/Place_rel[ToStop_rel];
			attribute<rdc>          FromPoint      := Stops/geometry[FromStop_rel];
			attribute<rdc>          ToPoint        := Stops/geometry[ToStop_rel];
			attribute<Time>         FromTime       := Time_rel;
			attribute<Time>         ToTime         := Time_rel[NextMoment];
			attribute<s_f>          Duration       := FromTime <= ToTime 
														? float32(sub_or_null(ToTime,FromTime))[s_f] 
														: float32(sub_or_null(ToTime + #Time,FromTime))[s_f]; // duration in seconds
			attribute<string>       Label          := 'Waiting at stop: ' + Stops/Name[FromStop_rel] + ' from ' + Time/Label[FromTime] + ' to ' + Time/Label[ToTime];
		}
		unit<uint32> NodeSet:= unique(doubledLinks/MomentXPlace), DialogData = "Place", DialogType = "map"
		{
			attribute<Places>    Place_rel  := pointRow(Values);
			attribute<Time>      Time_rel   := pointCol(Values);
			attribute<rdc>       geometry   := Places/geometry[Place_rel];
		}
	}

	unit<uint32> Static_Net := union_unit(allLinks, allLinks/WaitingAtStop)
	, Descr = "full public transport network, including transfer links and waiting at stop"
	{
		attribute<rdc>                     geometry (arc)                 := union_data(., allLinks/geometry, allLinks/WaitingAtStop/geometry);
		attribute<Places>                  FromPlace_rel                  := union_data(., allLinks/FromPlace, allLinks/WaitingAtStop/FromPlace);
		attribute<string>                  FromPlace_name                 := union_data(., allLinks/FromPlace_name, allLinks/WaitingAtStop/FromPlace_name);
		attribute<string>                  ToPlace_name                   := union_data(., allLinks/ToPlace_name, allLinks/WaitingAtStop/ToPlace_name);
		attribute<Places>                  ToPlace_rel                    := union_data(., allLinks/ToPlace, allLinks/WaitingAtStop/ToPlace);
		attribute<rdc>                     FromPoint                      := union_data(., allLinks/FromPoint, allLinks/WaitingAtStop/FromPoint);
		attribute<rdc>                     ToPoint                        := union_data(., allLinks/ToPoint, allLinks/WaitingAtStop/ToPoint);
		attribute<Stops>                   FromStop_rel                   := Places/Stop_rel[FromPlace_rel];
		attribute<Stops>                   ToStop_rel                     := Places/Stop_rel[ToPlace_rel];
		
		attribute<string>                  Label                          := union_data(., allLinks/Label, allLinks/WaitingAtStop/Label);
		attribute<Time>                    FromTime                       := union_data(., allLinks/fromTime, allLinks/WaitingAtStop/fromTime);
		attribute<Time>                    ToTime                         := union_data(., allLinks/toTime, allLinks/WaitingAtStop/toTime);
		attribute<s_f>                     Duration                       := union_data(., allLinks/Duration, allLinks/WaitingAtStop/Duration), IntegrityCheck = "ModelParameters/Add_OV_PriceInformation ? all(StaticNets/ScheduledLinks/HasPriceRelation) : TRUE";
		attribute<LinkTypes>               LinkType                       := union_data(., allLinks/LinkType, const(LinkTypes/V/Waiting_at_Stop,allLinks/WaitingAtStop,LinkTypes));
		attribute<NodeSet>                 F1                             := rlookup(point_xy(FromTime, FromPlace_rel), NodeSet/Values);
		attribute<NodeSet>                 F2                             := rlookup(point_xy(ToTime, ToPlace_rel), NodeSet/Values);
		attribute<km>                      Length                         := arc_length(geometry, m)[km];
		attribute<GTFS_Modes/Selectie> Mode_rel                       := union_data(., allLinks/Mode_rel, const(GTFS_Modes/Selectie/V/Waiting, allLinks/WaitingAtStop, GTFS_Modes/Selectie));
		attribute<uint32>                  Trips_rel                      := union_data(., allLinks/Trips_rel, const(0/0, allLinks/WaitingAtStop));
		attribute<Agencies>                Agency_rel                     := union_data(., allLinks/Agency_rel, const(0/0, allLinks/WaitingAtStop));
		attribute<Routes>                  Route_rel                      := union_data(., allLinks/Route_rel, const((0/0)[Routes], allLinks/WaitingAtStop));
		attribute<string>                  RouteName                      := union_data(., allLinks/RouteName, const('Waiting', allLinks/WaitingAtStop));
		attribute<string>                  RouteName_short                := union_data(., allLinks/RouteName_short, const('Waiting', allLinks/WaitingAtStop));

		attribute<uint32>                  LinkTypeSum (LinkTypes)        := pcount(LinkType);
		unit<uint32>                       NodeSet                        := allLinks/NodeSet;
		unit<uint32>                       NetCheck                       := connected_parts(F1, F2);
		// attribute<Concessiegebied>         Start_Concessiegebied_rel      := point_in_polygon(Stops/geometry[FromStop_rel], Concessiegebied/geometry);
		
		// attribute<string>                  Mode_Agency_CG_Lijn_identifier := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel] + '_' + RouteName_short;
		// attribute<string>                  Mode_Agency_CG_identifier      := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel];
		// attribute<string>                  Mode_Agency_identifier         := GTFS_Modes/Selectie/name[Mode_rel] +'_'+ Agencies/name[Agency_rel];
		
		// attribute<PrijsTabel>    PrijsTabel_rel_initial        := rlookup(Mode_Agency_CG_Lijn_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented1     := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented2     := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmentation   := MakeDefined(PrijsTabel_rel_augmented1, PrijsTabel_rel_augmented2);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev1 := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_identifier);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev2 := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_identifier);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev  := MakeDefined(PrijsTabel_rel_augmented_rev1, PrijsTabel_rel_augmented_rev2);
		// attribute<PrijsTabel>    PrijsTabel_rel_augmented      := MakeDefined(PrijsTabel_rel_augmentation, PrijsTabel_rel_augmented_rev);
		// attribute<PrijsTabel>    PrijsTabel_rel                := MakeDefined(PrijsTabel_rel_initial, PrijsTabel_rel_augmented);
		
		// unit<uint8> PrijsTabel := /SourceData/Infrastructuur/OVprijzen/PrijsTabel;
	}
}
