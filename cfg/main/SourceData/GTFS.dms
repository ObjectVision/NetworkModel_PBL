container GTFS : using = "geometries"
{
	#include<LoadFeeds.dms>
	#include<StudyAreaFeeds.dms>
	
	container CreateTransfersSet : using = "RelevantSelection"
	{
		unit<uint32> TransferFromStops := select_with_org_rel(Stops/nTransfers > 0)
		{
			attribute<rdc>       geometry       := Stops/geometry[org_rel];
			attribute<uint32>    nTransfers     := Stops/nTransfers[org_rel];
			attribute<string>    Label          := Stops/Label[org_rel];
			attribute<StopsGrid> GridId         := Stops/GridId[org_rel];
			attribute<uint32>    Grid1D         := Stops/Grid1D[org_rel];
			attribute<uint32>    cumu_in_grid   := Stops/cumu_in_grid[org_rel];
			attribute<upoint>    unique_id      := Stops/unique_id[org_rel];
			attribute<uint32>    first_transfer := cumulate(nTransfers) - nTransfers;
			attribute<uint32>    nEvents        := pcount(ScheduledSpaceTimeEvents/Stop_rel)[org_rel];
			attribute<Modes>     Mode_rel       := Stops/Mode_rel[org_rel];
		}
		
		unit<spoint> StopsGrid := Stops/StopsGrid;
		
		unit<uint32> Directions: NrOfRows = 5 
		{
			attribute<string> Label    : ['Top', 'Right', 'Bottom', 'Left', 'Centre'];
			attribute<int16>  row      : [0,1,0,-1,0];
			attribute<int16>  col      : [1,0,-1,0,0];
			attribute<spoint> geometry := point_xy(row,col, spoint);
		}
		
		unit<uint32> TransferPaths := range(uint32, 0, sum(TransferFromStops/nTransfers))
		{
			attribute<TransferFromStops>   first_from_stop     := rlookup(id(.), TransferFromStops/first_transfer);
			attribute<TransferFromStops>   from_trans_Stop_rel := cumulate(uint32(IsDefined(first_from_stop))) - 1;
			attribute<Stops>               from_Stop_rel       := TransferFromStops/org_rel[from_trans_Stop_rel];
			attribute<Modes> from_Mode           := TransferFromStops/Mode_rel[from_trans_Stop_rel];
			attribute<Modes> to_Mode             := Stops/Mode_rel[to_Stop_rel];
			
			attribute<bool>               NeedsTranferTimePenalty := Modes/IsGelijkvloers[from_Mode] == 1b && Modes/IsGelijkvloers[to_Mode] == 1b //van: bus, tram, walk    to bus, tram, walk  --> niks
																		? False
																		: Modes/IsGelijkvloers[from_Mode] == 1b && Modes/IsGelijkvloers[to_Mode] == 0b //van: bus, tram, walk to metro, rail, ferry --> penalty
																			? TRUE
																			: Modes/IsGelijkvloers[from_Mode] == 0b && Modes/IsGelijkvloers[to_Mode] == 0b //van: metro, rail, ferry to metro, rail, ferry --> penalty
																				? TRUE
																				: Modes/IsGelijkvloers[from_Mode] == 0b && Modes/IsGelijkvloers[to_Mode] == 1b //van: metro, rail, ferry to bus, tram, walk --> penalty
																					? TRUE
																					: (0/0)[bool];

			attribute<uint32>             nEvents            := pcount(ScheduledSpaceTimeEvents/Stop_rel)[from_Stop_rel];
			attribute<uint32>             first_trans_event  := cumulate(nEvents) - nEvents;
			attribute<upoint>             from_unique_id     := Stops/Unique_id[from_Stop_rel];
			attribute<StopsGrid>          from_StopsGrid_rel := Stops/StopsGrid_rel[from_Stop_rel];
			attribute<uint32>             nTop               := StopsGrid/nTop[from_StopsGrid_rel];
			attribute<uint32>             nRight             := StopsGrid/nRight[from_StopsGrid_rel];
			attribute<uint32>             nBottom            := StopsGrid/nBottom[from_StopsGrid_rel];
			attribute<uint32>             nLeft              := StopsGrid/nLeft[from_StopsGrid_rel];
			attribute<uint32>             first_trans        := TransferFromStops/first_transfer[from_trans_Stop_rel];
 
			attribute<Directions>         quad               := switch( //top, right, bottom, left, middle
																	 case(nTop > 0   	&& nTop    > (sub_or_null(id(.),first_trans)), uint32(0)) 
																	,case(nRight > 0 	&& nRight  > (sub_or_null(id(.),(first_trans + nTop))), uint32(1))
																	,case(nBottom > 0 	&& nBottom > (sub_or_null(id(.),(first_trans + nRight + nTop))), uint32(2))
																	,case(nLeft > 0 	&& nLeft   > (sub_or_null(id(.),(first_trans + nBottom + nRight + nTop))), uint32(3)) 
																	,4
																)[Directions];
																
			attribute<StopsGrid>          to_StopsGrid_rel          := (spoint(from_StopsGrid_rel) + Directions/geometry[quad])[StopsGrid];
			attribute<uint32>             to_StopsGrid_id          := StopsGrid/id[to_StopsGrid_rel];
			attribute<upoint>             to_unique_id       := point_xy(seq2, to_StopsGrid_id, upoint);
			attribute<Stops>              to_Stop_rel         := rlookup(to_unique_id, Stops/unique_id);
				
			attribute<uint32>             seq1               := id(.) 
																	- switch(
																		case(quad = 0, first_trans)
																		, case(quad = 1, first_trans + nTop)
																		, case(quad = 2, first_trans + nTop + nRight)
																		, case(quad = 3, first_trans + nTop + nRight + nBottom)
																		, first_trans + nTop + nRight + nBottom + nLeft
																	);
			attribute<uint32>             seq2               := quad = 4 && seq1 >= Stops/CumulateStop_in_grid[from_Stop_rel] ? seq1 + 1 : seq1;
			
			attribute<string>             Label              := 'Transfer from ' + Stops/Label[from_Stop_rel] + ' to ' + Stops/Label[to_Stop_rel];
			attribute<rdc>                geometry (arc)     := points2sequence(GenLines/Points,GenLines/Seq,GenLines/Ord);
			attribute<m>                  Distance           := arc_length(geometry, m);
			attribute<s_f>                minTransferTime    := Distance / ModelParameters/Advanced/TransferEffectiveSpeed;
			
			unit<uint32> GenLines:= union_unit(TransferPaths, TransferPaths)
			{
				attribute<rdc>              Points := union_data(., Stops/geometry[from_Stop_rel], Stops/geometry[to_Stop_rel]);
				attribute<TransferPaths>    Seq    := union_data(., id(TransferPaths), id(TransferPaths));
				attribute<uint32>           Ord    := union_data(., const(0,TransferPaths,uint32), const(1,TransferPaths,uint32));
			}
		}
		unit<uint32> TransfersByStart := range(uint32, 0, sum(TransferPaths/nEvents))
		{
			attribute<TransferPaths>            first_TransferPath      := rlookup(id(.), TransferPaths/first_trans_event);
			attribute<TransferPaths>            TransferPath_rel        := cumulate(uint32(IsDefined(first_TransferPath))) - 1;
			attribute<rdc>                      geometry (arc)          := TransferPaths/geometry[TransferPath_rel];
			attribute<Stops>                    fromStop_rel            := TransferPaths/from_Stop_rel[TransferPath_rel];
			attribute<Stops>                    toStop_rel              := TransferPaths/to_Stop_rel[TransferPath_rel];
			attribute<bool>                     NeedsTranferTimePenalty := TransferPaths/NeedsTranferTimePenalty[TransferPath_rel];
			attribute<uint32>                   cumu_events             := cumulate(const(1,.,uint32), TransferPath_rel) - 1;
			attribute<ScheduledSpaceTimeEvents> SSTE_rel                := rlookup(point_xy(cumu_events, fromStop_rel, upoint), ScheduledSpaceTimeEvents/unique_id);
			attribute<Time>                     fromTime                := ScheduledSpaceTimeEvents/Time_rel[SSTE_rel];
			attribute<s_f>                      Duration                := NeedsTranferTimePenalty ? TransferPaths/minTransferTime[TransferPath_rel] + convert(ModelParameters/OngelijkvloersPenalty, s_f) : TransferPaths/minTransferTime[TransferPath_rel];
			attribute<Time>                     toTime                  := fromTime + Duration[Time] < #Time 
																				? fromTime + Duration[Time] 
																				: sub_or_null(fromTime + Duration[Time],#Time);
			attribute<string>                   Label                   := 'Transfer: ' + Time/Label[fromTime] + ' @ ' + Stops/Name[fromStop_rel] + ' to ' + Time/Label[toTime] + ' @ ' + Stops/Name[toStop_rel], DialogType = "LabelText";
		}
	}
	
	
	#include<PublicTransportNet.dms>

	// container PublicTransportNet := templates/PublicTransportNetCreator_T(StudyAreaFeeds/Stops, StudyAreaFeeds/Links);
}