Template KetenRijger_T
{
	unit<uint64> Left; 
	unit<uint64> Right;
	unit<uint64> Tranfers;
	
	parameter<string> LeftStr;
	parameter<string> RightStr;
	////
	parameter<bool>   IsRight_RO    := left(RightStr, 1) == 'r' || left(RightStr, 1) == 'o';
	parameter<bool>   IsLeft_NS     := left(LeftStr, 1) == 'l' || left(RightStr, 1) == 'k';
	parameter<bool>   IsRight_NS    := left(RightStr, 1) == 'l' || left(RightStr, 1) == 'k';
		
	// unit<uint64> Tranfers2:=Tranfers; //hack
	// attribute<uint32> Transfer_xxx (Left) := rlookup(Left/c_ToTime_Stop_rel, Tranfers2/values);
	// unit<uint64> Join_Left_Transf   := join_equal_values_uint64(Transfer_xxx, Tranfers/uq_from_rel)
	unit<uint64> Join_Left_Transf   := join_equal_values_uint64(Left/uq_c_Time_Stop_To, Tranfers/uq_c_Time_Stop_From)
	, Descr = "join left To_rel met de de transfer from_rel"
	{
		attribute<Ct>               Left_price                 := first_rel -> Price;
		attribute<Ct>               Left_price_NonNS           := first_rel -> Price_NonNS;
		attribute<Ct>               Left_price_augm            := first_rel -> Price_augm;
		attribute<s>                Left_traveltime            := first_rel -> Traveltime;
		attribute<s>                Left_WaitingAtStop_time    := first_rel -> WaitingAtStop_time;
		attribute<s>                Left_Walking_time          := first_rel -> Walking_Time;
		
		// attribute<dam>              TravelDist_Bus             := first_rel -> TravelDist_Bus; 
		// attribute<dam>              Traveldist_Metro           := first_rel -> Traveldist_Metro; 
		// attribute<dam>              Traveldist_Tram            := first_rel -> Traveldist_Tram; 
		// attribute<dam>              Traveldist_Rail            := first_rel -> Traveldist_Rail; 
		// attribute<dam>              Traveldist_Ferry           := first_rel -> Traveldist_Ferry; 
		
		attribute<s>                Transfer_Transfer_time      := second_rel -> Transfer_time;
		attribute<s>                Transfer_WaitingAtStop_time := second_rel -> WaitingAtStop_time;
		attribute<s>                Transfer_Walking_time       := second_rel -> Walking_Time;
		
		attribute<Ct>               Transfer_Walking_Time_cost := rounded_convert(Transfer_Walking_time[min_f] * ModelParameters/Transfer_Walking_Time_Costs, Ct);
		attribute<Ct>               Transfer_Waiting_Time_cost := rounded_convert(Transfer_WaitingAtStop_time[min_f] * ModelParameters/Transfer_Waiting_Time_Costs, Ct);
		
		attribute<s>                Traveltime                 := Left_traveltime + Transfer_Transfer_time, Descr = "Ã–V-time + waiting at stop + transfer walking time";
		attribute<s>                WaitingAtStop_time         := Left_WaitingAtStop_time + Transfer_WaitingAtStop_time; 
		attribute<s>                Walking_time               := Left_Walking_time + Transfer_Walking_time;

		attribute<uq_c_Time_Stop>   Left_uq_c_Time_Stop_From  := first_rel -> uq_c_Time_Stop_From;
		attribute<uq_c_Time_Stop>   Left_uq_c_Time_Stop_to     := first_rel -> uq_c_Time_Stop_To;
		attribute<uq_c_Time_Stop>   Right_uq_c_Time_Stop_From  := second_rel -> uq_c_Time_Stop_From;
		attribute<uq_c_Time_Stop>   Right_uq_c_Time_Stop_to    := second_rel -> uq_c_Time_Stop_To;
		
		
		
		//deze moet in fromTS rel zijn
		// attribute<c_Time_Stops>       LeftT_c_toTime_Stop_rel    := second_rel -> c_ToTime_Stop_rel, Descr = "de to_rel van de transfers"; 
		// attribute<uq_c_FromTime_Stop> LeftT_uq_c_toTime_Stop_rel := rlookup(LeftT_c_toTime_Stop_rel, uq_c_FromTime_Stop/c_FromTime_Stop_rel), Descr = "de to_rel van de transfers"; 
		// attribute<uq_c_Time_Stop>   LeftT_uq_c_toTime_Stop_rel := rlookup(LeftT_c_toTime_Stop_rel, uq_c_Time_Stop/values), Descr = "de to_rel van de transfers"; 
		
		attribute<NS_Stations>      First_NS_Station           := first_rel -> First_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden wat de eerste en laaste ns-stations zijn.";
		attribute<NS_Stations>      Last_NS_Station            := first_rel -> Last_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden wat de eerste en laaste ns-stations zijn.";
		attribute<Time>             Laatste_NS_Uitstap_Tijd    := first_rel -> Laatste_NS_Uitstap_Tijd, Descr = "om te kijken of een volgende NS rit lange afstandkorting moet behouden, moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Laatste_RO_Uitstap_Tijd    := first_rel -> Laatste_RO_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
	}

	// unit<uint64> Join_LeftT_Right   := join_equal_values_uint64(Join_Left_Transf/LeftT_uq_c_toTime_Stop_rel, Right/uq_c_Time_Stop_rel), Descr = "join Left+Transfer To_rel met de de Right from_rel"
	unit<uint64> Join_LeftT_Right   := join_equal_values_uint64(Join_Left_Transf/Right_uq_c_Time_Stop_to, Right/uq_c_Time_Stop_From), Descr = "join Left+Transfer To_rel met de de Right from_rel"
	, Descr = "deze set bevat alle mogelijke 'paden' en kan dus later geaggregeerd worden door group-by OD. En dus per OD-pair het kortste/goedkoopste pad te kiezen."
	{
		attribute<Ct>               Left_price_NonNS                := first_rel -> Left_price_NonNS;
		attribute<Ct>               Left_price                      := first_rel -> Left_price;
		attribute<Ct>               Left_price_augm                 := first_rel -> Left_price_augm;
		attribute<Ct>               Left_Transfer_Walking_Time_cost := first_rel -> Transfer_Walking_Time_cost;
		attribute<Ct>               Left_Transfer_Waiting_Time_cost := first_rel -> Transfer_Waiting_Time_cost;
		attribute<s>                Left_traveltime                 := first_rel -> Traveltime;
		attribute<s>                WaitingAtStop_time              := first_rel -> WaitingAtStop_time;  //nodig?
		attribute<s>                Walking_time                    := first_rel -> Walking_time;  //nodig?
		
		// attribute<dam>              Left_TravelDist_Bus             := first_rel -> TravelDist_Bus;
		// attribute<dam>              Left_TravelDist_Metro           := first_rel -> Traveldist_Metro;
		// attribute<dam>              Left_TravelDist_Tram            := first_rel -> Traveldist_Tram;
		// attribute<dam>              Left_TravelDist_Rail            := first_rel -> Traveldist_Rail;
		// attribute<dam>              Left_TravelDist_Ferry           := first_rel -> Traveldist_Ferry;
		
		attribute<Ct>               Right_price                     := second_rel -> Price;
		attribute<Ct>               Right_price_augm                := second_rel -> Price_augm;
		attribute<s>                Right_traveltime                := second_rel -> Traveltime;
		
		// attribute<dam>              Right_TravelDist_Bus            := second_rel -> TravelDist_Bus;
		// attribute<dam>              Right_TravelDist_Metro          := second_rel -> Traveldist_Metro;
		// attribute<dam>              Right_TravelDist_Tram           := second_rel -> Traveldist_Tram;
		// attribute<dam>              Right_TravelDist_Rail           := second_rel -> Traveldist_Rail;
		// attribute<dam>              Right_TravelDist_Ferry          := second_rel -> Traveldist_Ferry;
		
		attribute<Ct>               Price                           := PriceNeedsToBeReplaced ? Left_price_NonNS + Price_NS : Left_price + Right_price, Descr = "te betalen prijs";
		attribute<Ct>               Price_augm                      := Left_price_augm + Left_Transfer_Walking_Time_cost + Left_Transfer_Waiting_Time_cost + Right_price_augm, Descr = "te betalen prijs, plus kosten voor tijd van vervoer/wachten die niet beprijst zijn. "; 
		attribute<Ct>               Price_NonNS                     := =IsRight_RO ? 'Left_price_NonNS + Right_price' : 'Left_price_NonNS';
		attribute<s>                Traveltime                      := Left_traveltime + Right_traveltime;

		// attribute<dam>              TravelDist_Bus                  := Left_TravelDist_Bus + Right_TravelDist_Bus;
		// attribute<dam>              Traveldist_Metro                := Left_TravelDist_Metro + Right_TravelDist_Metro;
		// attribute<dam>              Traveldist_Tram                 := Left_TravelDist_Tram + Right_TravelDist_Tram;
		// attribute<dam>              Traveldist_Rail                 := Left_TravelDist_Rail + Right_TravelDist_Rail;
		// attribute<dam>              Traveldist_Ferry                := Left_TravelDist_Ferry + Right_TravelDist_Ferry;
		
		attribute<uint32>           PriceTime_Score                 := =ModelParameters/MinimiseCriterium == 'Price'
																		? 'value(Price_augm, uint32) * value(ModelParameters/MaxTravelTime[s], uint32) + value(Traveltime, uint32)'
																		: 'value(Traveltime, uint32) * 10000 + value(Price_augm, uint32)';
		
		attribute<Left>             Left_rel                        := Join_Left_Transf/first_rel[first_rel];
		attribute<Right>            Right_rel                       := second_rel;

		attribute<Time>             Left_Laatste_NS_Uitstap_Tijd    := first_rel -> Laatste_NS_Uitstap_Tijd, Descr = "om te kijken of een volgende NS rit lange afstandkorting moet behouden, moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Left_Laatste_RO_Uitstap_Tijd    := first_rel -> Laatste_RO_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Right_instap_tijd               := second_rel -> From_Time_rel, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, of dat een nieuwe NS-rit begint moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Right_uitstap_tijd              := second_rel -> To_Time_rel, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Laatste_NS_Uitstap_Tijd         := =IsRight_NS ? 'Right_uitstap_tijd' : 'Left_Laatste_NS_Uitstap_Tijd';
		attribute<Time>             Laatste_RO_Uitstap_Tijd         := =IsRight_RO ? 'Right_uitstap_tijd' : 'Left_Laatste_RO_Uitstap_Tijd';
		
		attribute<c_Time_Stops>     c_fromTime_Stop_rel             := Left/c_fromTime_Stop_rel[left_rel];
		attribute<c_Time_Stops>     c_toTime_Stop_rel               := Right/c_ToTime_Stop_rel[right_rel];
		
		attribute<Stops>            Left_From_Stop_rel              := value(Left/c_fromTime_Stop_rel[left_rel] % uint64(#Stops), Stops); //debug
		attribute<Stops>            Left_To_Stop_rel                := value(Left/c_ToTime_Stop_rel[left_rel] % uint64(#Stops), Stops); //debug
		attribute<Stops>            Right_From_Stop_rel             := value(Right/c_fromTime_Stop_rel[right_rel] % uint64(#Stops), Stops); //debug
		attribute<Stops>            Right_To_Stop_rel               := value(Right/c_ToTime_Stop_rel[right_rel] % uint64(#Stops), Stops); //debug
		
		attribute<Stops>            From_Stop_rel                   := value(Left/c_fromTime_Stop_rel[left_rel] % uint64(#Stops), Stops);
		attribute<Stops>            To_Stop_rel                     := value(Right/c_ToTime_Stop_rel[right_rel] % uint64(#Stops), Stops);
		attribute<bool>             IsTravelToSameStop              := from_Stop_rel == To_Stop_rel;

		//recalc NS-prices
		attribute<NS_Stations>      First_NS_Station                := first_rel -> First_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
		attribute<NS_Stations>      Last_NS_Station                 := =IsRight_NS ? 'second_rel -> Last_NS_Station' : 'first_rel -> Last_NS_Station', Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
		attribute<bool>             Right_IsNieuwePrijsReis         := IsRight_NS && (Left_Laatste_NS_Uitstap_Tijd + MaxOverstapTijdBinnenPrijsReis < Right_instap_tijd);
		parameter<Time>             MaxOverstapTijdBinnenPrijsReis  := convert(35[min_f],s_f)[Time];
		attribute<c_NS_start_end>   c_NS_start_end_rel              := combine_data(c_NS_start_end, First_NS_Station, Last_NS_Station);
		attribute<Ct>               Price_NS                        := rounded_convert(rjoin(c_NS_start_end_rel
																		, TariefEenhedenMatrix/c_NS_start_end_rel
																		, TariefEenhedenMatrix/Prijs), Ct);
		attribute<bool>             PriceNeedsToBeReplaced          := IsLeft_NS && IsRight_NS && NOT(Right_IsNieuwePrijsReis), Descr = "Als beide zijden NS zijn, dan moet de prijs herbekenend worden. Want anders heb je twee opstartprijs en geen langeafstandskorting. Tenzij de overstap langer dan 35 minuten is.";
	
		attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel      := rlookup(c_FromTime_Stop_rel, uq_c_FromTime_Stop/values);
		attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel        := rlookup(c_ToTime_Stop_rel, uq_c_ToTime_Stop/values);
		// attribute<c_FromTS_ToTS>    OD_pair_rel                     := combine_data(c_FromTS_ToTS, Left/uq_c_FromTime_Stop_rel[left_rel], Right/uq_c_ToTime_Stop_rel[right_rel]);
		attribute<c_FromTS_ToTS>        OD_pair_rel                     := combine_data(c_FromTS_ToTS, uq_c_FromTime_Stop_rel, uq_c_ToTime_Stop_rel);
	
		unit<uint64> Valid := select_with_attr_by_cond(.,NOT(IsTravelToSameStop))
		{
			attribute<Result>     Result_rel                   := rlookup(OD_pair_rel, Result/values);
		}
	}
	
	unit<uint64> Result := unique_uint64(Join_LeftT_Right/Valid/OD_pair_rel)
	, Descr = "Geaggregeerde set naar 'OD-paren' om minimalisatie criterium op toe te passen"
	{
		attribute<uq_c_FromTime_Stop>     uq_c_FromTime_Stop_rel      := union_data(., value(values / #uq_c_ToTime_Stop, uq_c_FromTime_Stop));
		attribute<uq_c_ToTime_Stop>       uq_c_ToTime_Stop_rel        := union_data(., value(values % #uq_c_ToTime_Stop, uq_c_ToTime_Stop));
		attribute<c_Time_Stops>           c_FromTime_Stop_rel         := union_data(., uq_c_FromTime_Stop/c_FromTime_Stop_rel[uq_c_FromTime_Stop_rel]);
		attribute<c_Time_Stops>           c_ToTime_Stop_rel           := union_data(., uq_c_ToTime_Stop/c_ToTime_Stop_rel[uq_c_ToTime_Stop_rel]);
		
		attribute<Join_LeftT_Right/Valid> Min_Index                   := union_data(., min_index(Join_LeftT_Right/Valid/PriceTime_Score, Join_LeftT_Right/Valid/Result_rel));
		attribute<Ct>                     Price                       := union_data(., Min_Index -> Price);
		attribute<Ct>                     Price_NonNS                 := union_data(., Min_Index -> Price_NonNS);
		attribute<Ct>                     Price_augm                  := union_data(., Min_Index -> Price_augm);
		attribute<uint32>                 PriceTime_Score             := union_data(., Min_Index -> PriceTime_Score);
		attribute<s>                      Traveltime                  := union_data(., Min_Index -> Traveltime);
		attribute<s>                      WaitingAtStop_time          := union_data(., Min_Index -> WaitingAtStop_time);
		attribute<s>                      Walking_time                := union_data(., Min_Index -> Walking_time);
		
		// attribute<dam>                    TravelDist_Bus              := union_data(., Min_Index -> TravelDist_Bus);
		// attribute<dam>                    Traveldist_Metro            := union_data(., Min_Index -> Traveldist_Metro);
		// attribute<dam>                    Traveldist_Tram             := union_data(., Min_Index -> Traveldist_Tram);
		// attribute<dam>                    Traveldist_Rail             := union_data(., Min_Index -> Traveldist_Rail);
		// attribute<dam>                    Traveldist_Ferry            := union_data(., Min_Index -> Traveldist_Ferry);
		
		attribute<NS_Stations>            First_NS_Station            := union_data(., Min_Index -> First_NS_Station);
		attribute<NS_Stations>            Last_NS_Station             := union_data(., Min_Index -> Last_NS_Station);
		attribute<Right>                  Right_rel                   := union_data(., Min_Index -> Right_rel);
		
		attribute<Stops>                  From_Stop_rel               := value(c_fromTime_Stop_rel % uint64(#Stops), Stops); //debug
		attribute<Stops>                  To_Stop_rel                 := value(c_ToTime_Stop_rel % uint64(#Stops), Stops); //debug
		
		attribute<Time>                   Laatste_NS_Uitstap_Tijd     := union_data(., Min_Index -> Laatste_NS_Uitstap_Tijd);
		attribute<Time>                   Laatste_RO_Uitstap_Tijd     := union_data(., Min_Index -> Laatste_RO_Uitstap_Tijd), Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
	}
}