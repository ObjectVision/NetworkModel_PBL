Template KetenRijger_T
{
	unit<uint32> Left; 
	unit<uint32> Right;
	unit<uint32> Transfers;
	
	parameter<string> LeftStr;
	parameter<string> RightStr;
	////
	parameter<bool>   HasLeft_RO    := IsDefined(strpos(LeftStr , 'R'));
	parameter<bool>   HasRight_RO   := IsDefined(strpos(RightStr, 'R'));
	parameter<bool>   HasLeft_NS    := IsDefined(strpos(LeftStr , 'L')) || IsDefined(strpos(LeftStr, 'K'));
	parameter<bool>   HasRight_NS   := IsDefined(strpos(RightStr, 'L')) || IsDefined(strpos(RightStr, 'K'));
	parameter<bool>   Has_RO        := HasLeft_RO || HasRight_RO;
	parameter<bool>   Has_NS        := HasLeft_NS || HasRight_NS;
	parameter<bool>   HasBoth       := Has_RO && Has_NS;
	
	parameter<bool>   NS_overstap_mogelijk := HasLeft_NS && HasRight_NS;
	parameter<bool>   NS_overstap_zeker    := right(LeftStr, 1)=='L' && left(RightStr, 1)=='L';
	parameter<bool>   RO_overstap_mogelijk := HasLeft_RO && HasRight_RO;

	parameter<Time>   MaxOverstapTijdBinnenPrijsReis  := convert(/ModelParameters/Advanced/MaxOverstapTijdVoorBasistarief,s_f)[Time]; // MOVE to ModelParameters/Advanced


	container StartCalc0{parameter<string> KetenName := Leftstr+RightStr;}
	container StartCalc := PhaseContainer(StartCalc0, 'Start calculating '+string(StartCalc0/KetenName)+' for '+BlockDomain/name[BlockDomain_id]);
	
	unit<uint64> Join_Left_Transf   := join_equal_values_uint64(Left/uq_c_ToTime_Stop_rel, Transfers/uq_c_Exit_rel)
	, Descr = "join left To_rel met de de transfer from_rel"
	{
		attribute<Left>      Left_rel      := first_rel;
		attribute<Transfers> Transfers_rel := second_rel;
	}

	unit<uint64> Join_LeftT_Right   := join_equal_values_uint64(Join_Left_Transf/transfers_rel->uq_c_Reboard_rel, Right/uq_c_FromTime_Stop_rel), Descr = "join Left+Transfer To_rel met de de Right from_rel"
	, Descr = "deze set bevat alle mogelijke 'paden' en kan dus later geaggregeerd worden door group-by OD. En dus per OD-pair het kortste/goedkoopste pad te kiezen."
	{
		attribute<Left>             Left_rel                        := first_rel -> Left_rel;
		attribute<Transfers>        Transfers_rel                   := first_rel -> Transfers_rel;
		attribute<Right>            Right_rel                       := second_rel;
					
		attribute<s> Traveltime := Left_rel->traveltime + Transfers_rel->Transfer_Time+ Right_rel->traveltime;
				
		attribute<uq_c_FromTime_Stop> uq_c_FromTime_Stop_rel := left_rel ->uq_c_FromTime_Stop_rel;
		attribute<uq_c_ToTime_Stop>   uq_c_ToTime_Stop_rel   := right_rel->uq_c_ToTime_Stop_rel;
		
		attribute<Stops> From_Stop_rel                   := value(uq_c_FromTime_Stop_rel->values % uint64(#Stops), Stops);
		attribute<Stops> To_Stop_rel                     := value(uq_c_ToTime_Stop_rel  ->Values % uint64(#Stops), Stops);
		
		attribute<bool>  IsTravelToSameStop              := from_Stop_rel == To_Stop_rel;

		attribute<bool> IsJourneyLongerThanAllowed     := Traveltime > convert(/ModelParameters/MaxOVTime, s);

		attribute<bool> is_valid_connection := NOT(IsTravelToSameStop) && NOT(IsJourneyLongerThanAllowed);

		unit<uint64> Valid1 := select(is_valid_connection)
		{
			attribute<Time> TravelTime           := collect_by_cond(Valid1, Join_LeftT_RightTravelTime);
			// attribute<Time> RO_overstap_resttijd := collect_by_cond(Valid1, Join_LeftT_Right/RO_overstap_resttijd);
			
			attribute<c_FromTS_ToTS> OD_pair_rel := collect_by_cond(Valid1, is_valid_connection, ../OD_pair_rel);
			unit<uint32> OD_pair_enum := unique_uint32(OD_pair_rel);
			attribute<OD_pair_enum> OD_pair_enum_rel := rlookup(OD_pair_rel, OD_pair_enum/values);
		
			unit<uint64> pareto_vergelijker := join_equal_values_uint64(valid1/OD_pair_enum_rel, valid1/OD_pair_enum_rel)
			{
				attribute<bool> is_less_or_equal := 
					=AsList('Valid1/'+ Classifications/ParetoAttr/Name+'[./first_rel] <= Valid1/'+Classifications/ParetoAttr/Name+'[./second_rel]',  ' && ');
				attribute<bool> is_equal := 
					=AsList('Valid1/'+ Classifications/ParetoAttr/Name+'[./first_rel] == Valid1/'+Classifications/ParetoAttr/Name+'[./second_rel]',  ' && ');
					
				attribute<bool> is_less := is_less_or_equal && not(is_equal);
			}
			attribute<bool> pareto_condition := not(any(pareto_vergelijker/is_less, pareto_vergelijker/second_rel));
		}
		attribute<bool> valid_pareto_optimal := recollect_by_cond(is_valid_connection, Valid1/pareto_condition, false);		
	}
	
	unit<uint64> JoinResult := select(Join_LeftT_Right/valid_pareto_optimal)
	{
		attribute<Left>             Left_rel                        := collect_by_cond(JoinResult, Join_LeftT_Right/Left_rel);
		attribute<Transfers>        Transfers_rel                   := collect_by_cond(JoinResult, Join_LeftT_Right/Transfers_rel);
		attribute<Right>            Right_rel                       := collect_by_cond(JoinResult, Join_LeftT_Right/Right_rel);
		
		attribute<bool>             RO_overstap_toegestaan          := =RO_overstap_mogelijk ? 'Left_rel->Laatste_RO_Uitstap_Tijd + MaxOverstapTijdBinnenPrijsReis >= Right_rel->Instaptijd_RO' : 'const(false,. )';
		attribute<Ct>               Price_I                         := 
				= RO_overstap_mogelijk ? 'RO_overstap_toegestaan ? max_elem(Left_rel->price_I, Right_rel->price_I) : Left_rel->price_I + Right_rel->price_I'
				: HasLeft_RO           ? 'Left_rel->price_I' 
				: HasRight_RO          ? 'Right_rel->price_I' 
				: 'const(9999[Ct], .)';
		attribute<Ct>               Price_O                         :=
				= RO_overstap_mogelijk ? 'Left_rel->Price_O + Right_rel->Price_O'
				: HasLeft_RO  ? 'Left_rel->Price_O' 
				: HasRight_RO ? 'Right_rel->Price_O' 
				: 'const(9999[Ct], .)';
		attribute<Ct>               Price_T                         := Left_rel->Price_T + Transfers_rel->Time_cost + Right_rel->Price_T;
		
		// deze tussenstapppen zijn alleen nodig indien NS_overstap_mogelijk t.b.v. herberekeking van het treinkaartje		
		attribute<c_NS_start_end>   c_NS_start_end_rel              := =NS_overstap_mogelijk  ? 'combine_data(c_NS_start_end, left_rel ->First_NS_Station, right_rel-> Last_NS_Station)' : 'const(null_u, .)';
				
		attribute<Ct>               Price_NS                        := =NS_overstap_mogelijk  ? 'rjoin(c_NS_start_end_rel, TariefEenhedenMatrix/c_NS_start_end_rel, TariefEenhedenMatrix/Prijs_Ct)' : 'const(9999[Ct], .)' ;
																		
		attribute<bool>             NS_overstap_toegestaan          := =NS_overstap_mogelijk ? 'Left_rel->Laatste_NS_Uitstap_Tijd + MaxOverstapTijdBinnenPrijsReis >= Right_rel->Instaptijd_NS' : 'const(false,. )';
		attribute<bool>             NS_overstap_voordelig           := =NS_overstap_mogelijk ? NS_overstap_zeker?'const(true, .)':'NS_overstap_toegestaan && IsDefined(Price_NS) && Price_NS < Left_rel->Price_L + Right_rel->Price_L' : 'const(false,. )';
		attribute<Ct>               Price_L                         := =NS_overstap_zeker ? 'Price_NS' : NS_overstap_mogelijk ? 'NS_overstap_voordelig ? Price_NS : Right_rel->Price_L' : HasLeft_NS ? 'Left_rel->price_L' : HasRight_NS ? 'Right_rel->price_L' : 'const(0[Ct], .)';
		attribute<Ct>               Price_F_inherited               := ='Left_rel->Price_F' + (strlen(RightStr) > 1 ? '+ Right_rel->Price_F' : ''), Descr = "Final costs inherited from left and right sources";
		attribute<Ct>               Price_F                         := =NS_overstap_zeker or not(NS_overstap_mogelijk) ? 'Price_F_inherited' : 'NS_overstap_voordelig ? Price_F_inherited : Price_F_inherited + Left_rel->Price_L', Descr = "Final costs, not subject to subsequent recalculation";
		
		attribute<NS_Stations>      First_NS_Station               : Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.",
			=	= NS_overstap_zeker    ? 'left_rel ->First_NS_Station'
				: NS_overstap_mogelijk ? 'NS_overstap_voordelig ? left_rel ->First_NS_Station : Right_rel->First_NS_Station' 
		        : HasRight_NS ? 'right_rel->First_NS_Station' 
				: HasLeft_NS  ? 'left_rel->First_NS_Station' 
				: 'const(null_u,.)';
		attribute<NS_Stations>      Last_NS_Station                : Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.",
			=	= HasRight_NS ? 'Right_rel->Last_NS_Station' 
		        : HasLeft_NS ? 'Left_rel->Last_NS_Station' 
				: 'const(null_u,.)';
		
		
		attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel      := Left_rel ->uq_c_FromTime_Stop_rel;
		attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel        := Right_rel->uq_c_ToTime_Stop_rel;
		attribute<c_FromTS_ToTS>        OD_pair_rel                 := combine_data(c_FromTS_ToTS, uq_c_FromTime_Stop_rel, uq_c_ToTime_Stop_rel);
		
		
		attribute<s>                TravelTime                      := collect_by_cond(JoinResult, Join_LeftT_Right/TravelTime);		
		
		attribute<Ct>               Price                           := = (Has_RO ? 'Price_O + Price_I ':'')+(HasBoth?'+':'')+(Has_NS?'Price_L':'')+(HasLeft_NS?' + Price_F':''), Descr = "te betalen prijs";
		attribute<Ct>               Price_augm                      := Price + Price_T, Descr = "te betalen prijs, plus kosten voor tijd van vervoer/wachten die niet beprijst zijn. "; 
		attribute<uint32>           PriceTime_Score                 := =ModelParameters/MinimiseCriterium == 'Price'
																		? 'value(Price_augm, uint32) * value(ModelParameters/MaxTravelTime[s], uint32) + value(Traveltime, uint32)'
																		: 'value(Traveltime, uint32) * 10000 + value(Price_augm, uint32)';
																		
		attribute<x/Result>     Result_rel                   := rlookup(OD_pair_rel, x/Result/values);
	}
	
	container x
	: Descr = "hack om deadlock te omzeilen"
	, URL = "https://github.com/ObjectVision/GeoDMS/issues/965"
	{
		unit<uint32> Result := unique_uint32(JoinResult/OD_pair_rel)
		, Descr = "Geaggregeerde set naar 'OD-paren' om minimalisatie criterium op toe te passen"
		{
			attribute<uq_c_FromTime_Stop>     uq_c_FromTime_Stop_rel      := value(values / #uq_c_ToTime_Stop, uq_c_FromTime_Stop);
			attribute<uq_c_ToTime_Stop>       uq_c_ToTime_Stop_rel        := value(values % #uq_c_ToTime_Stop, uq_c_ToTime_Stop);
			
			attribute<JoinResult>             Min_Index                   := min_index(JoinResult/PriceTime_Score, JoinResult/Result_rel);
			
			attribute<Ct>                     Price                       := Min_Index -> Price  ;
			attribute<Ct>                     Price_O                     := Min_Index -> Price_O;
			attribute<Ct>                     Price_I                     := Min_Index -> Price_I;
			attribute<Ct>                     Price_F                     := Min_Index -> Price_F;
			attribute<Ct>                     Price_T                     := Min_Index -> Price_T;
			attribute<Ct>                     Price_L                     := Min_Index -> Price_L;
			attribute<Ct>                     Price_augm                  := Min_Index -> Price_augm;
			
			attribute<s>                      TravelTime                  := Min_Index -> TravelTime;
			
	
			attribute<Left>                   Left_rel                    := Min_Index->Left_rel;
			attribute<Right>                  Right_rel                   := Min_Index->Right_rel;
			
			attribute<dam>                    TravelDist_Bus              := Left_rel -> TravelDist_Bus   + Right_rel -> TravelDist_Bus;
			attribute<dam>                    TravelDist_Metro            := Left_rel -> Traveldist_Metro + Right_rel -> Traveldist_Metro;
			attribute<dam>                    TravelDist_Tram             := Left_rel -> Traveldist_Tram  + Right_rel -> Traveldist_Tram;
			attribute<dam>                    TravelDist_Rail             := Left_rel -> Traveldist_Rail  + Right_rel -> Traveldist_Rail;
			attribute<dam>                    TravelDist_Ferry            := Left_rel -> Traveldist_Ferry + Right_rel -> Traveldist_Ferry;
					
			attribute<NS_Stations>            First_NS_Station            := Min_Index -> First_NS_Station;
			attribute<NS_Stations>            Last_NS_Station             := Min_Index -> Last_NS_Station;
			
			attribute<Time>             Laatste_NS_Uitstap_Tijd         := =HasRight_NS ? 'Right_rel->Laatste_NS_Uitstap_Tijd' : 'Left_rel->Laatste_NS_Uitstap_Tijd', Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
			attribute<Time>             Laatste_RO_Uitstap_Tijd         := =HasRight_RO ? 'Right_rel->Laatste_RO_Uitstap_Tijd' : 'Left_rel->Laatste_RO_Uitstap_Tijd', Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		}
	}
	
	container Fence := PhaseContainer(x, 'Calculated: '+StartCalc/KetenName+' for keten '+BlockDomain/name[BlockDomain_id]);
	unit<uint32> Result := Fence/Result;

}