Template KetenRijger_T
{
	unit<uint64> Left; //11191
	unit<uint64> Right;
	unit<uint64> Tranfers;
	
	parameter<string> LeftStr;
	parameter<string> RightStr;
	parameter<bool>   IsRight_RO   := left(RightStr, 1) == 'r' || left(RightStr, 1) == 'o';
	parameter<bool>   IsLeft_NS    := left(LeftStr, 1) == 'l' || left(RightStr, 1) == 'k';
	parameter<bool>   IsRight_NS   := left(RightStr, 1) == 'l' || left(RightStr, 1) == 'k';
	
	unit<uint64> c_FromTP_ToTP       := combine_unit_uint64(Left/uq_c_FromTime_Stop, Right/uq_c_ToTime_Stop);

	unit<uint64> Join_Left_Transf   := join_equal_values_uint64(Left/uq_c_ToTime_Stop_rel, Tranfers/from_rel_in_UqFirstDom), Descr = "join left To_rel met de de transfer from_rel"
	{
		attribute<Ct>               Left_price                 := first_rel -> Price;
		attribute<Ct>               Left_price_NonNS           := first_rel -> Price_NonNS;
		attribute<s>                Left_traveltime            := first_rel -> Traveltime;
		
		attribute<dam>              TravelDist_Bus             := first_rel -> TravelDist_Bus; 
		attribute<dam>              Traveldist_Metro           := first_rel -> Traveldist_Metro; 
		attribute<dam>              Traveldist_Tram            := first_rel -> Traveldist_Tram; 
		attribute<dam>              Traveldist_Rail            := first_rel -> Traveldist_Rail; 
		attribute<dam>              Traveldist_Ferry           := first_rel -> Traveldist_Ferry; 
		
		attribute<s>                Transfer_time              := second_rel -> Transfer_time;
		attribute<s>                WaitingAtStop_time         := second_rel -> WaitingAtStop_time;
		attribute<s>                Walking_time               := second_rel -> Walking_Time;
		
		attribute<Ct>               Transfer_Walking_Time_cost := rounded_convert(Walking_Time[min_f] * ModelParameters/Transfer_Walking_Time_Costs, Ct);
		attribute<Ct>               Transfer_Waiting_Time_cost := rounded_convert(WaitingAtStop_time[min_f] * ModelParameters/Transfer_Waiting_Time_Costs, Ct);
		
		attribute<s>                Traveltime                 := Left_traveltime + Transfer_time, Descr = "ÖV-time + waiting at stop + transfer walking time";
		// attribute<Ct>               Price_augm                 := Left_price + Transfer_Walking_Time_cost + Transfer_Waiting_Time_cost, Descr = "ÖV-price + waiting at stop costs+ transfer walking time costs";
		
		attribute<c_Time_Stops>    LeftT_c_toTime_Stop_rel   := second_rel -> c_toTime_Stop_rel, Descr = "de to_rel van de transfers"; 
		unit<uint64>                NextJoinFromDom            := Right/uq_c_FromTime_Stop;
		attribute<NextJoinFromDom>  to_rel_inNextJoinFromDom   := rlookup(LeftT_c_toTime_Stop_rel, NextJoinFromDom/values), Descr = "de transfer to-rel in right from-rel values"; 
		
		attribute<NS_Stations>      First_NS_Station           := first_rel -> First_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
		attribute<NS_Stations>      Last_NS_Station            := first_rel -> Last_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
		attribute<Time>             Laatste_NS_Uitstap_Tijd    := first_rel -> Laatste_NS_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		attribute<Time>             Laatste_RO_Uitstap_Tijd    := first_rel -> Laatste_RO_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		attribute<CoropP>           CoropP_rel                 := Stops/CoropP_rel[first_rel -> From_Stop_rel], Descr = "tile based on location for next step.";
	}
	
	container Join_LeftT_Right_perCorop :=
		for_each_ne(
			CoropP/name
			, 'Join_LeftT_Right_Tiled_T('+string(id(CoropP))+')'
		);
	
	Template Join_LeftT_Right_Tiled_T
	{
		parameter<CoropP> CoropP_id;
		///
		container FenceHack0
		{
			parameter<CoropP> CoropP_id := ../CoropP_id;
		}
		container FenceHack := PhaseContainer(FenceHack0, 'CoropP_id'+string(FenceHack0/CoropP_id));
		// container FenceHack := FenceContainer(FenceHack0, 'CoropP_id'+string(FenceHack0/CoropP_id));
		
		
		unit<uint64> Tile := select_with_attr_by_cond(Join_Left_Transf, Join_Left_Transf/CoropP_rel == CoropP_id);
		
		unit<uint64> Join_LeftT_Right   := join_equal_values_uint64(Tile/to_rel_inNextJoinFromDom, Right/uq_c_FromTime_Stop_rel), Descr = "join Left+Transfer To_rel met de de Right from_rel"
		, Descr = "deze set bevat alle mogelijke 'paden' en kan dus later geaggregeerd worden door group-by OD. En dus per OD-pair het kortste/goedkoopste pad te kiezen."
		{
			attribute<Ct>               Left_price_NonNS                := first_rel -> Left_price_NonNS;
			attribute<Ct>               Left_price                      := first_rel -> Left_price;
			attribute<Ct>               Left_Transfer_Walking_Time_cost := first_rel -> Transfer_Walking_Time_cost;
			attribute<Ct>               Left_Transfer_Waiting_Time_cost := first_rel -> Transfer_Waiting_Time_cost;
			attribute<s>                Left_traveltime                 := first_rel -> Traveltime;
			attribute<s>                Left_WaitingAtStop_time         := first_rel -> WaitingAtStop_time;  //nodig?
			attribute<s>                Left_Walking_time               := first_rel -> Walking_time;  //nodig?
			
			attribute<dam>               Left_TravelDist_Bus            := first_rel -> TravelDist_Bus;
			attribute<dam>               Left_TravelDist_Metro          := first_rel -> Traveldist_Metro;
			attribute<dam>               Left_TravelDist_Tram           := first_rel -> Traveldist_Tram;
			attribute<dam>               Left_TravelDist_Rail           := first_rel -> Traveldist_Rail;
			attribute<dam>               Left_TravelDist_Ferry          := first_rel -> Traveldist_Ferry;
			
			attribute<Ct>               Right_price                     := second_rel -> Price;
			attribute<s>                Right_traveltime                := second_rel -> Traveltime;
			
			attribute<dam>              Right_TravelDist_Bus            := second_rel -> TravelDist_Bus;
			attribute<dam>              Right_TravelDist_Metro          := second_rel -> Traveldist_Metro;
			attribute<dam>              Right_TravelDist_Tram           := second_rel -> Traveldist_Tram;
			attribute<dam>              Right_TravelDist_Rail           := second_rel -> Traveldist_Rail;
			attribute<dam>              Right_TravelDist_Ferry          := second_rel -> Traveldist_Ferry;
			
			attribute<Ct>               Price                           := PriceNeedsToBeReplaced ? Left_price_NonNS + Price_NS : Left_price + Right_price, Descr = "te betalen prijs";
			attribute<Ct>               Price_augm                      := Price + Left_Transfer_Walking_Time_cost + Left_Transfer_Waiting_Time_cost, Descr = "te betalen prijs, plus kosten voor tijd van vervoer/wachten die niet beprijst zijn. "; 
			attribute<Ct>               Price_NonNS                     := =IsRight_RO ? 'Left_price_NonNS + Right_price' : 'Left_price_NonNS';
			attribute<s>                Traveltime                      := Left_traveltime + Right_traveltime;
			
			attribute<dam>              TravelDist_Bus                  := Left_TravelDist_Bus + Right_TravelDist_Bus;
			attribute<dam>              Traveldist_Metro                := Left_TravelDist_Metro + Right_TravelDist_Metro;
			attribute<dam>              Traveldist_Tram                 := Left_TravelDist_Tram + Right_TravelDist_Tram;
			attribute<dam>              Traveldist_Rail                 := Left_TravelDist_Rail + Right_TravelDist_Rail;
			attribute<dam>              Traveldist_Ferry                := Left_TravelDist_Ferry + Right_TravelDist_Ferry;
			
			attribute<uint32>           PriceTime_Score                 := =ModelParameters/MinimiseCriterium == 'Price'
																			? 'value(Price_augm, uint32) * value(ModelParameters/MaxTravelTime[s], uint32) + value(Traveltime, uint32)'
																			: 'value(Traveltime, uint32) * 10000 + value(Price_augm, uint32)';
			
			attribute<Left>             Left_rel                        := Tile/first_rel[first_rel];
			attribute<Right>            Right_rel                       := second_rel;
			

			attribute<Time>             Left_Laatste_NS_Uitstap_Tijd    := first_rel -> Laatste_NS_Uitstap_Tijd, Descr = "om te kijken of een volgende NS rit als nieuwe reis telt, moeten we de laatste uitstaptijd bijhouden";
			attribute<Time>             Left_Laatste_RO_Uitstap_Tijd    := first_rel -> Laatste_RO_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
			attribute<Time>             Right_instap_tijd               := second_rel -> From_Time_rel, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
			attribute<Time>             Right_uitstap_tijd              := second_rel -> To_Time_rel, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
			attribute<Time>             Laatste_NS_Uitstap_Tijd         := =IsRight_NS ? 'Right_uitstap_tijd' : 'Left_Laatste_NS_Uitstap_Tijd';
			attribute<Time>             Laatste_RO_Uitstap_Tijd         := =IsRight_RO ? 'Right_uitstap_tijd' : 'Left_Laatste_RO_Uitstap_Tijd';
			
			
			attribute<Stops>           From_Stop_rel                  := value(Left/c_fromTime_Stop_rel[left_rel] % uint64(#Stops), Stops);
			attribute<Stops>           To_Stop_rel                    := value(Right/c_ToTime_Stop_rel[right_rel] % uint64(#Stops), Stops);
			attribute<bool>            IsTravelToSameStop             := from_Stop_rel == To_Stop_rel;

			//recalc NS-prices
			attribute<NS_Stations>      First_NS_Station                := first_rel -> First_NS_Station, Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
			attribute<NS_Stations>      Last_NS_Station                 := =IsRight_NS ? 'second_rel -> Last_NS_Station' : 'first_rel -> Last_NS_Station', Descr = "om achteraf de NS-kosten te herberekenen moeten we bijhouden van de eerste en laaste ns-stations zijn.";
			attribute<bool>             Right_IsNieuwePrijsReis         := IsRight_NS && (Left_Laatste_NS_Uitstap_Tijd + MaxOverstapTijdBinnenPrijsReis < Right_instap_tijd);
			parameter<Time>             MaxOverstapTijdBinnenPrijsReis  := convert(35[min_f],s_f)[Time];
			attribute<c_NS_start_end>   c_NS_start_end_rel              := combine_data(c_NS_start_end, First_NS_Station, Last_NS_Station);
			attribute<Ct>               Price_NS                        := rounded_convert(rjoin(c_NS_start_end_rel
																			, TariefEenhedenMatrix/c_NS_start_end_rel
																			, TariefEenhedenMatrix/Prijs), Ct);
			attribute<bool>             PriceNeedsToBeReplaced          := IsLeft_NS && IsRight_NS && NOT(Right_IsNieuwePrijsReis), Descr = "Als beide zijden NS zijn, dan moet de prijs herbekenend worden. Want anders heb je twee opstartprijs en geen langeafstandskorting. Tenzij de overstap langer dan 35 minuten is.";
			
			attribute<c_FromTP_ToTP>    OD_pair_rel                     := combine_data(c_FromTP_ToTP, Left/uq_c_FromTime_Stop_rel[left_rel], Right/uq_c_ToTime_Stop_rel[right_rel]);
		
			unit<uint64> Valid := select_with_attr_by_cond(.,NOT(IsTravelToSameStop))
			{
				attribute<Result_Tiled>     Result_rel                   := rlookup(OD_pair_rel, Result_Tiled/values);
			}
		}
		
		unit<uint64> Result_Tiled := unique_uint64(Join_LeftT_Right/Valid/OD_pair_rel)
		, Descr = "Geaggregeerde set naar 'OD-paren' om minimalisatie criterium op toe te passen"
		// , StorageName = "='%LocalDataProjDir%/Temp/'+LeftStr+RightStr+'_'+Time/TemplatableTextShrt[EersteVertrekMoment]+'_to_'+Time/TemplatableTextShrt[LaatsteVertrekMoment+convert(ModelParameters/MaxTravelTime,s_f)[Time]]+'_'+/ModelParameters/Analysis_date+'.fss'"
		{
			unit<uint64> uq_c_FromTime_Stop := Left/uq_c_FromTime_Stop;
			unit<uint64> uq_c_ToTime_Stop   := Right/uq_c_ToTime_Stop;
		
			attribute<uq_c_FromTime_Stop>    uq_c_FromTime_Stop_rel     := value(values / #Right/uq_c_ToTime_Stop, Left/uq_c_FromTime_Stop);
			attribute<uq_c_ToTime_Stop>      uq_c_ToTime_Stop_rel       := value(values % #Right/uq_c_ToTime_Stop, Right/uq_c_ToTime_Stop);
			attribute<c_Time_Stops>          c_FromTime_Stop_rel        := uq_c_FromTime_Stop/c_FromTime_Stop_rel[uq_c_FromTime_Stop_rel];
			attribute<c_Time_Stops>          c_ToTime_Stop_rel          := uq_c_ToTime_Stop/c_ToTime_Stop_rel[uq_c_ToTime_Stop_rel];
			
			attribute<Join_LeftT_Right/Valid> Min_Index                   := ='min_index(Join_LeftT_Right/Valid/PriceTime_Score, Join_LeftT_Right/Valid/Result_rel)', DisableStorage = "true";
			attribute<Ct>                     Price                       := Min_Index -> Price;
			attribute<Ct>                     Price_NonNS                 := Min_Index -> Price_NonNS;
			attribute<Ct>                     Price_augm                  := Min_Index -> Price_augm;
			attribute<uint32>                 PriceTime_Score             := Min_Index -> PriceTime_Score;
			attribute<s>                      Traveltime                  := Min_Index -> Traveltime;
			
			attribute<dam>                    TravelDist_Bus              := Min_Index -> TravelDist_Bus;
			attribute<dam>                    Traveldist_Metro            := Min_Index -> Traveldist_Metro;
			attribute<dam>                    Traveldist_Tram             := Min_Index -> Traveldist_Tram;
			attribute<dam>                    Traveldist_Rail             := Min_Index -> Traveldist_Rail;
			attribute<dam>                    Traveldist_Ferry            := Min_Index -> Traveldist_Ferry;
			
			attribute<NS_Stations>            First_NS_Station            := Min_Index -> First_NS_Station;
			attribute<NS_Stations>            Last_NS_Station             := Min_Index -> Last_NS_Station;
			attribute<Right>                  Right_rel                   := Min_Index -> Right_rel;
			
			
			attribute<Time>                   Laatste_NS_Uitstap_Tijd     := Min_Index -> Laatste_NS_Uitstap_Tijd;
			attribute<Time>                   Laatste_RO_Uitstap_Tijd     := Min_Index -> Laatste_RO_Uitstap_Tijd, Descr = "om te kijken of een volgende regionale rit R of O moet zijn na een K of L, moeten we de laatste uitstaptijd bijhouden";
		}
		
		unit<uint64> Result_Tiled_Fence := PhaseContainer(Result_Tiled, 'Calculated Tile '+string(FenceHack/CoropP_id)+' '+CoropP/name[CoropP_id]+': '+string(#Result_Tiled)+' OD-pairs for '+LeftStr+ ' to '+RightStr+ '');
		// unit<uint64> Result_Tiled_Fence := FenceContainer(Result_Tiled, 'Calculated Tile '+string(FenceHack/CoropP_id)+' '+CoropP/name[CoropP_id]+': '+string(#Result_Tiled)+' OD-pairs for '+LeftStr+ ' to '+RightStr+ '');
	}
	
	// unit<uint32> names := SubItem_PropValues(Union_Tiled_Results,'name');
	// parameter<string> Generate := 'Ready', ExplicitSuppliers = "=AsList('Union_Tiled_Results/'+names/name,';')";

	unit<uint64> Result   := ='union_unit_uint64('+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence')+')'
	, Descr = "Deze set bevat de geunionede resultaten per corop, dus hier moet nogmaals een unique met min_index op los worden gelaten."
	// , StorageName = "='%LocalDataProjDir%/Temp/'+LeftStr+RightStr+'.fss'"
	{
		attribute<Ct>                  Price                      := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Price')+')';
		attribute<Ct>                  Price_augm                 := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Price_augm')+')';
		attribute<Ct>                  Price_NonNS                := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Price_NonNS')+')';
		attribute<s>                   Traveltime                 := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Traveltime')+')';

		attribute<dam>                 TravelDist_Bus             := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/TravelDist_Bus')+')';
		attribute<dam>                 Traveldist_Metro           := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Traveldist_Metro')+')';
		attribute<dam>                 Traveldist_Tram            := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Traveldist_Tram')+')';
		attribute<dam>                 Traveldist_Rail            := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Traveldist_Rail')+')';
		attribute<dam>                 Traveldist_Ferry           := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Traveldist_Ferry')+')';
	
		attribute<uint32>              PriceTime_Score            := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/PriceTime_Score')+')';
		attribute<Time>                Laatste_NS_Uitstap_Tijd    := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Laatste_NS_Uitstap_Tijd')+')';
		attribute<Time>                Laatste_RO_Uitstap_Tijd    := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Laatste_RO_Uitstap_Tijd')+')';
		attribute<NS_Stations>         First_NS_Station           := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/First_NS_Station')+')';
		attribute<NS_Stations>         Last_NS_Station            := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Last_NS_Station')+')';
		
		// attribute<Left>                Left_rel                   := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Left_rel')+')';
		attribute<Right>               Right_rel                  := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/Right_rel')+')';
		
		attribute<c_Time_Stops>       c_FromTime_Stop_rel       := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/c_FromTime_Stop_rel')+')';
		attribute<c_Time_Stops>       c_ToTime_Stop_rel         := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/c_ToTime_Stop_rel')+')';
		attribute<uq_c_FromTime_Stop> uq_c_FromTime_Stop_rel    := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/uq_c_FromTime_Stop_rel')+')';
		attribute<uq_c_ToTime_Stop>   uq_c_ToTime_Stop_rel      := ='union_data(.,'+AsItemList('Join_LeftT_Right_perCorop/'+CoropP/name+'/Result_Tiled_Fence/uq_c_ToTime_Stop_rel')+')';
		attribute<Stops>              From_Stop_rel             := value(c_FromTime_Stop_rel % uint64(#Stops), Stops);
		
		unit<uint64> uq_c_FromTime_Stop := Left/uq_c_FromTime_Stop;
		unit<uint64> uq_c_ToTime_Stop   := Right/uq_c_ToTime_Stop;
	}
}