container PublicTransport_Prep
{
	container impl
	{
		unit<uint32> org := =Org_domain
		{
			attribute<rdc>                   geometry       := =impl/Org_domain+'/geometry';
			attribute<string>                name           := =impl/Org_domain+'/name';
			attribute<float32>               nr_inwoners    := =impl/Org_domain+'/nr_inwoners[float32]';
		}
		
		unit<uint32> dest := impl/dest_src
		{
			attribute<rdc>                   geometry       := impl/dest_src/geometry;
		}
		
		parameter<string> Org_domain        := rjoin(lowercase(ModelParameters/Orgset),  lowercase(Advanced/org_domain_list/label),  Advanced/org_domain_list/path);
		parameter<string> Dest_domain       := rjoin(lowercase(ModelParameters/DestSet), lowercase(Advanced/dest_domain_list/label), Advanced/dest_domain_list/path);
		
		unit<uint32> dest_src := =Dest_domain
		{
			attribute<uint32>                nr_items_of_interest := =Dest_domain+'/'+Advanced/items_of_interest;
			attribute<rdc>                   geometry             := =Dest_domain+'/geometry';
			attribute<string>                name                 := =Dest_domain+'/name';
			attribute<string>                label                := =Dest_domain+'/label';
		}
		
		parameter<string>   PT_path_str           := 'SourceData/Infrastructuur/GTFS/PublicTransportNet'; 
		unit<uint32>        PT_net                := =PT_path_str+''; //indirection, want dan kun je die later gebruiken in een select_with_attr_by_cond waarbij alle attributen worden opgehaald.
		
		unit<uint32>        Places             := union_unit(PT_net/SL_Places, org, dest)
		, Descr = "All stops, orgs and dests"
		{
			attribute<rdc>              geometry      := union_data(., PT_net/SL_Places/geometry, org/geometry, dest/geometry);
			attribute<string>           label         := union_data(., PT_net/SL_Places/label, org/name, dest/name);
			attribute<org>              Origin_rel    := union_data(., const(null_u, PT_net/SL_Places), id(org), const(null_u, dest));
			attribute<dest>             Dest_rel      := union_data(., const(null_u, PT_net/SL_Places), const(null_u, org), id(dest));
			attribute<PT_net/SL_Places> SL_Places_rel := union_data(., id(PT_net/SL_Places), const(null_u, org), const(null_u, dest));
			attribute<Stops>            Stop_rel      := PT_net/SL_Places/Stop_rel[SL_Places_rel];
			attribute<Infrastructuur/OVprijzen/NS/NS_stations> NS_Stations_rel := Stops/NS_Stations_rel[Stop_rel];
			attribute<RMT_Stops>                               RMT_Stop_rel    := invert(RMT_Stops/Place_rel);
			attribute<RM_Stops>                                RM_Stop_rel     := invert(RM_Stops/Place_rel);
			attribute<Ric_Stops>                               Ric_Stop_rel    := invert(Ric_Stops/Place_rel);
			attribute<R_Stops>                                 R_Stop_rel      := invert(T_Stops/Place_rel);
			
			attribute<Stops>                                   Stops_rel       := Stop_rel;
			attribute<R_Stops>                                 R_Stops_rel     := R_Stop_rel;
			attribute<Ric_Stops>                               Ric_Stops_rel   := Ric_Stop_rel;
			attribute<RMT_Stops>                               RMT_Stops_rel   := RMT_Stop_rel;
			attribute<RM_Stops>                                RM_Stops_rel    := RM_Stop_rel;
			attribute<OVF_Stops>                               OVF_Stops_rel   := invert(OVF_Stops/Place_rel);
			
			attribute<RegioIndelingen/CoropP> CoropP_rel := point_in_polygon(geometry, RegioIndelingen/CoropP/geometry);
		}
		
		unit<uint64> c_Time_Stop_Routes    := combine_unit_uint64(c_Time_Stops,Routes);
		unit<uint64> c_Time_Stops          := /SourceData/Infrastructuur/GTFS/c_Time_Stops;
		unit<uint64> c_Time_Places         := combine_unit_uint64(Time, Places);
	
		unit<uint32>        Stops                 := =PT_path_str+'/Stops'
		{
			attribute<string> name      := =PT_path_str+'/Stops/name';
			attribute<rdc>    geometry  := =PT_path_str+'/Stops/geometry';
			attribute<RegioIndelingen/CoropP> CoropP_rel := point_in_polygon(geometry, RegioIndelingen/CoropP/geometry);
			attribute<Places> Place_rel := invert(Places/stop_rel);
		}
		unit<uint32>        RMT_Stops              := select_with_attr_by_cond(Stops, Stops/Mode_rel == GTFS_Modes/Selectie/V/Rail || Stops/Mode_rel == GTFS_Modes/Selectie/V/Metro || Stops/Mode_rel == GTFS_Modes/Selectie/V/Tram);
		unit<uint32>        RM_Stops               := select_with_attr_by_cond(Stops, Stops/Mode_rel == GTFS_Modes/Selectie/V/Rail || Stops/Mode_rel == GTFS_Modes/Selectie/V/Metro);
		unit<uint32>        R_Stops                := select_with_attr_by_cond(Stops, Stops/Mode_rel == GTFS_Modes/Selectie/V/Rail);
		unit<uint32>        Ric_Stops              := select_with_attr_by_cond(Stops, Stops/IsNSICStation);
		unit<uint32>        OVF_Stops              := select_with_attr_by_cond(Stops, Stops/IsOVFietsStation);
		
		parameter<Time>     EersteVertrekMoment    := first(Advanced/MeasureMoments/Moment);
		parameter<Time>     LaatsteVertrekMoment   := last(Advanced/MeasureMoments/Moment);
		parameter<Time>     LaatsteAankomstMoment  := LaatsteVertrekMoment + (convert( ModelParameters/MaxOVTime , s_f )[ Time ]);
		unit<uint32>        Routes                 := =PT_path_str+'/Routes';
		unit<uint32>        NS_Stations            := SourceData/Infrastructuur/OVprijzen/NS/NS_Stations;
		unit<uint8>         Modes                  := GTFS_Modes/Selectie;
		unit<uint8>         PrijsTabel             := SourceData/Infrastructuur/OVprijzen/PrijsTabel;
		unit<uint32>        Provincie              := SourceData/RegioIndelingen/Provincie;
		unit<uint8>         Concessiegebied        := SourceData/RegioIndelingen/Concessiegebied;
		unit<uint32>        CoropP                 := SourceData/RegioIndelingen/CoropP;
		unit<uint32>        c_NS_start_end         := /SourceData/Infrastructuur/OVprijzen/NS/NS_tariefeenheden_matrix/c_NS_start_end;
		unit<uint32>        TariefEenhedenMatrix   := Infrastructuur/OVprijzen/NS/NS_tariefeenheden_matrix/ODMatrix;
		unit<uint16>        ToBeCalculated_Ketens  := /Classifications/Ketens/ToBeCalculated;
		unit<uint16>        Toegestane_Ketens      := /Classifications/Ketens/Toegestaan;
		
		unit<uint32> PTnet_prep := =impl/PT_path_str+''
		{
			attribute<bool>   IsSub_from := From_Time_rel >= impl/EersteVertrekMoment ;
			attribute<bool>   IsSub_to   := To_Time_rel   < impl/LaatsteAankomstMoment;
			attribute<bool>   IsSub_dur  := duration <= convert(ModelParameters/MaxOVTime , s_f);
		}

		container Set_R := Get_Windowed_Agency_Set_T(' &&  '+impl/PT_path_str+'/Agency_rel->IsRO &&  '+impl/PT_path_str+'/Duration > 0f'), Descr = "subset of public transport net for the relevant time windows and agency-set.", using = "impl";
		container Set_L := Get_Windowed_Agency_Set_T(' && ('+impl/PT_path_str+'/Agency_rel == Agencies/V/ns || ('+impl/PT_path_str+'/Mode_rel == impl/Modes/V/Waiting && IsDefined('+impl/PT_path_str+'/c_NS_start_end_rel))) && '+impl/PT_path_str+'/Duration > 0f');
		
		unit<uint32> All_Time_Stops := union_unit_uint32(OD_L/Result, OD_R/Result)
		{
			attribute<impl/c_Time_Stops>       c_FromTime_Stop_rel       := union_data(., OD_L/Result/c_FromTime_Stop_rel, OD_R/Result/c_FromTime_Stop_rel);
			attribute<impl/c_Time_Stops>       c_ToTime_Stop_rel         := union_data(., OD_L/Result/c_ToTime_Stop_rel  , OD_R/Result/c_ToTime_Stop_rel  );
		}
		#include<MakeODs.dms>
		
		unit<uint32> BlockSelections := Impl/Stops
		{
			attribute<.>      rnd_rel       := rnd_permutation(0, .);
		}	
		unit<uint32>      BlockDomain   := range(0, ModelParameters/NumberOfStopBlocks)
		{
			attribute<string> name          := 'Block_'+string(id(.)+1)+'of'+string(max(id(.))+1);
			attribute<uint64> BlockOffset   := min_elem(uint64(id(.)) * uint64(ModelParameters/MaxStopBlockSize), uint64(#BlockSelections));
			attribute<uint64> BlockEnd      := min_elem(BlockOffset + uint64(ModelParameters/MaxStopBlockSize), uint64(#BlockSelections));
			attribute<uint32> BlockSize     := uint32(BlockEnd - BlockOffset);
		}
	} 

	container Create_Optimised_Network_Walking  := Templates/CreateNetwork_Efficient_T(impl/Org, impl/Dest, SourceData/Infrastructuur/OSM/Network_Walking, 'Walking', TRUE), Descr = "Network for pre- and post-transport.";
	container Create_Optimised_Network_Cycling  := Templates/CreateNetwork_Efficient_T(impl/Org, impl/Dest, SourceData/Infrastructuur/OSM/Network_Cycling, 'Cycling', TRUE), Descr = "Network for pre- and post-transport.";
	container Create_Optimised_Network_EBike    := Templates/CreateNetwork_Efficient_T(impl/Org, impl/Dest, SourceData/Infrastructuur/OSM/Network_Cycling, 'E_Biking', TRUE), Descr = "Network for pre- and post-transport.";

	unit<uint64> Direct_OD := =/ModelParameters/Advanced/AllowDirectCyclingOverWalking 
									? '/NetworkSetup/PrivateTransport/Cycling/Calc_Traveltimes_maxspeed_cycling/Traveltimes'
									: '/NetworkSetup/PrivateTransport/Walking/Calc_Traveltimes_maxspeed_walking/Traveltimes'
	{
		attribute<s>       Duration_seconds                 := convert(Impedance, s);
		attribute<dam>     Distance                         := alt_imp[dam]; 
		attribute<ct>      Price_Augm                       := =ModelParameters/Advanced/AllowDirectCyclingOverWalking 
																	? 'rounded_convert(Impedance[min_f] * ModelParameters/Direct_Cycling_Time_Costs, ct)'
																	: 'rounded_convert(Impedance[min_f] * ModelParameters/Direct_Walking_Time_Costs, ct)';
		attribute<impl/Modes>   Mode_rel                         :=  =ModelParameters/Advanced/AllowDirectCyclingOverWalking 
																	? 'const(impl/Modes/V/Cycling, .)'
																	: 'const(impl/Modes/V/Walking, .)';
	}

	container TimeInvariantConnections := 
		for_each_ne(
			TimeInvariantTypes/name
			, 'Create_TimeInvariantConnection_T('+string(id(TimeInvariantTypes))+'[TimeInvariantTypes])'
		), Descr = "i.e. voor/na transport";
	
	Template Create_TimeInvariantConnection_T  : using = "/SourceData/Infrastructuur/GTFS/RelevantSelection"
	{
		parameter<TimeInvariantTypes> TimeInvariantTypes_rel;
		///
		parameter<string> ConnectionType := TimeInvariantTypes/ConnectionType[TimeInvariantTypes_rel];
		parameter<string> Mode           := TimeInvariantTypes/Mode[TimeInvariantTypes_rel];
		parameter<string> OriginSet      := TimeInvariantTypes/OriginSet[TimeInvariantTypes_rel];
		parameter<string> DestinationSet := TimeInvariantTypes/DestinationSet[TimeInvariantTypes_rel];
		parameter<string> Mode_abbrev    := TimeInvariantTypes/Mode_abbrev[TimeInvariantTypes_rel];
		parameter<Modes>  Mode_rel       := TimeInvariantTypes/Mode_rel[TimeInvariantTypes_rel];
		parameter<string> NetworkType    := TimeInvariantTypes/NetworkType[TimeInvariantTypes_rel];
		parameter<string> VN_Transport   := TimeInvariantTypes/VN_Transport[TimeInvariantTypes_rel];
		unit<uint32>      Network        := ='SourceData/Infrastructuur/OSM/Network_'+NetworkType;
		
		container Create_Routes      := ='Templates/CreateNetwork_Pedestrian_Bike_T(
												PublicTransport_Prep/Impl/'+OriginSet+ //inStart
												', PublicTransport_Prep/Impl/'+DestinationSet+ //inEind
												', Network' //Roads
												', Mode' //TravelMode
												', NetworkType' //NetworkType
												', ConnectionType' //ConnectionType
												', Create_Optimised_Network_'+Mode+ //Optimised_Network
											')';
	}


	unit<uint64> uq_c_FromTime_Stop := unique_uint64(impl/All_Time_Stops/c_FromTime_Stop_rel), using = "impl"
	{
		attribute<impl/c_Time_Stops> c_FromTime_Stop_rel      := values;
		attribute<Time>              From_Time_rel            := value(c_FromTime_Stop_rel / uint64(#Stops), Time); //debug
		attribute<Stops>             From_Stop_rel            := value(c_FromTime_Stop_rel % uint64(#Stops), Stops);//debug
		attribute<string>            Label                    := Stops/name[From_Stop_rel]+' @ '+Time/TemplatableText[From_Time_rel];
	}
	unit<uint64> uq_c_ToTime_Stop   := unique_uint64(impl/All_Time_Stops/c_ToTime_Stop_rel), using = "impl"
	{
		attribute<impl/c_Time_Stops> c_ToTime_Stop_rel        := values;
		attribute<Time>              To_Time_rel              := value(c_ToTime_Stop_rel / uint64(#Stops), Time);//debug
		attribute<Stops>             To_Stop_rel              := value(c_ToTime_Stop_rel % uint64(#Stops), Stops); //debug
		attribute<string>            Label                    := Stops/name[To_Stop_rel]+' @ '+Time/TemplatableText[To_Time_rel];
	}
	
	unit<uint64> c_FromTS_ToTS      := combine_unit_uint64(uq_c_FromTime_Stop, uq_c_ToTime_Stop);
	
	#include<Transfers.dms>


	container KetenGeneratie_PerBlock :=
		for_each_ne(
			impl/BlockDomain/name
			, 'KetenGeneratie_PerBlock_T('+string(id(impl/BlockDomain))+')'
		), using = "impl";
		
	Template KetenGeneratie_PerBlock_T
	{
		parameter<BlockDomain> BlockDomain_id;
		///
		container StartCalc0{parameter<string> BlockDomain_name := BlockDomain/name[../BlockDomain_id], IntegrityCheck = "uint64(ModelParameters/MaxStopBlockSize) * uint64(ModelParameters/NumberOfStopBlocks) > uint64(#BlockSelections)";}
		container StartCalc := PhaseContainer(StartCalc0, 'Start calculating '+string(StartCalc0/BlockDomain_name)+', with block size of '+string(BlockDomain/BlockSize[BlockDomain_id]));
		
		container Keten_Generatie := 
			for_each_ne(iif(impl/ToBeCalculated_Ketens/right == '', '',  impl/ToBeCalculated_Ketens/name) // skip the monodial chains as they are defined explicitly below
			,  'KetenRijger_T(
					'+impl/ToBeCalculated_Ketens/left+'/Result' //left unit
					',OD_'+impl/ToBeCalculated_Ketens/right+'/Result' //right unit
					',Transfers/'+impl/ToBeCalculated_Ketens/transfer_name+'/Result' //transfer unit
					','+Quote(impl/ToBeCalculated_Ketens/Left)+ //left name str
					','+Quote(impl/ToBeCalculated_Ketens/Right)+ //right name str
				')' 
			)
		{
			container L  
			{
				unit<uint32> result := select_with_attr_by_cond(OD_L/Result, BlockSelections/rnd_rel[OD_L/Result/From_Stop_rel] / ModelParameters/MaxStopBlockSize == BlockDomain_id);
			}
			container R 
			{
				unit<uint32> result := select_with_attr_by_cond(OD_R/Result, BlockSelections/rnd_rel[OD_R/Result/From_Stop_rel] / ModelParameters/MaxStopBlockSize == BlockDomain_id);
			}
		}
		
		unit<uint64> ToegestaneKetens := ='union_unit_uint64('+AsItemList('Keten_Generatie/'+impl/Toegestane_Ketens/name+'/Result')+')', using = "impl"
		{
			attribute<Toegestane_Ketens>    Toegestane_Keten_rel           := ='union_data(., '+AsList('const('+string(id(Toegestane_Ketens))+'[Toegestane_Ketens], Keten_Generatie/'+Toegestane_Ketens/name+'/Result)', ',')+')';
			attribute<ct>                   Price                          := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Price')+')';
			attribute<ct>                   Price_augm                     := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Price_augm')+')';
			attribute<s>                    Traveltime                     := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Traveltime')+')';
			attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel         := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/uq_c_FromTime_Stop_rel')+')';
			attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel           := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/uq_c_ToTime_Stop_rel')+')';
			attribute<Stops>                From_Stop_rel                  := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/uq_c_FromTime_Stop_rel->From_Stop_rel')+')';
			attribute<Stops>                To_Stop_rel                    := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/uq_c_ToTime_Stop_rel->To_Stop_rel')+')';

			attribute<dam>                  TravelDist_Bus                 := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/TravelDist_Bus')+')';
			attribute<dam>                  Traveldist_Metro               := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Traveldist_Metro')+')';
			attribute<dam>                  Traveldist_Tram                := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Traveldist_Tram')+')';
			attribute<dam>                  Traveldist_Rail                := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Traveldist_Rail')+')';
			attribute<dam>                  Traveldist_Ferry               := ='union_data(., '+AsItemList('Keten_Generatie/'+Toegestane_Ketens/name+'/Result/Traveldist_Ferry')+')';
			
			unit<uint64>                    StarEvent2Stop                 := union_unit_uint64(Stops, Stops);	
			attribute<StarEvent2Stop>       OD_pair_key                    := combine_data(StarEvent2Stop, uq_c_FromTime_Stop_rel, To_Stop_rel); //fka OD_key
			unit<uint32>                    OD_pair                        := unique_uint32(OD_pair_key);
			attribute<OD_pair>              OD_pair_rel                    := rlookup(OD_pair_key, OD_pair/values);
			attribute<.>                    good_candidate_of_OD (OD_Pair) := ='min_index('+first(ParetoAttr/Name)+', OD_pair_rel)', Descr = "do a pre-selection to limit the size of the pareto_candidate selection. Here, first select a point which is a good starting point from which to compare others.";
			attribute<.>                    good_candidate_in_OD           := good_candidate_of_OD[OD_pair_rel];
			
			unit<uint8> ParetoAttr := Classifications/FinalParetoAttr;
			
			attribute<bool>                 pe_compared_to_good_candidate  := =AsList(replace('@PA@ < good_candidate_in_OD->@PA@', '@PA@', ParetoAttr/Name), ' or '), Descr = "Option is Pareto efficient compared to good candidate.";
			attribute<bool>                 is_also_good_candidate         := pe_compared_to_good_candidate or (ID(.) == good_candidate_in_OD);
					
			unit<uint64> Valid := select(is_also_good_candidate)
			{
				attribute<OD_Pair>    OD_pair_rel      := collect_by_cond(., ../OD_pair_rel);
				attribute<s>          TravelTime       := collect_by_cond(., ../TravelTime);
				attribute<Ct>         Price            := collect_by_cond(., ../Price);
				attribute<Ct>         Price_augm       := collect_by_cond(., ../Price_augm);
			}
			unit<uint64> pareto_vergelijker := join_equal_values_uint64(Valid/OD_pair_rel, Valid/OD_pair_rel)
			{
				attribute<bool>       is_less_or_equal := =AsList('Valid/'+ ParetoAttr/Name+'[./first_rel] <= Valid/'+ParetoAttr/Name+'[./second_rel]',  ' and ');
				attribute<bool>       is_equal         := =AsList('Valid/'+ ParetoAttr/Name+'[./first_rel] == Valid/'+ParetoAttr/Name+'[./second_rel]',  ' and ');
				attribute<bool>       is_less          := is_less_or_equal && (not(is_equal) || first_rel < second_rel);
			}
			attribute<bool>                 Valid_pareto_condition (Valid) := not(any(pareto_vergelijker/is_less, pareto_vergelijker/second_rel));
			attribute<bool>                 pareto_condition               := recollect_by_cond(is_also_good_candidate, Valid_pareto_condition, false);
		} 

		container BlockResultContainer
		: Descr = "hack om deadlock te omzeilen"
		, URL = "https://github.com/ObjectVision/GeoDMS/issues/965"
		{
			unit<uint64> Result := select(ToegestaneKetens/pareto_condition) //fka uq_OD_key
			{ 
				attribute<ct>                   Price                       := collect_by_cond(., ToegestaneKetens/Price);
				attribute<ct>                   Price_augm                  := collect_by_cond(., ToegestaneKetens/Price_augm);
				attribute<s>                    Traveltime                  := collect_by_cond(., ToegestaneKetens/Traveltime);

				attribute<Toegestane_Ketens>    Toegestane_Keten_rel        := collect_by_cond(., ToegestaneKetens/Toegestane_Keten_rel);
				attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel      := collect_by_cond(., ToegestaneKetens/uq_c_FromTime_Stop_rel);
				attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel        := collect_by_cond(., ToegestaneKetens/uq_c_ToTime_Stop_rel);
				
				attribute<dam>                  TravelDist_Bus              := collect_by_cond(., ToegestaneKetens/TravelDist_Bus);
				attribute<dam>                  Traveldist_Metro            := collect_by_cond(., ToegestaneKetens/Traveldist_Metro);
				attribute<dam>                  Traveldist_Tram             := collect_by_cond(., ToegestaneKetens/Traveldist_Tram);
				attribute<dam>                  Traveldist_Rail             := collect_by_cond(., ToegestaneKetens/Traveldist_Rail);
				attribute<dam>                  Traveldist_Ferry            := collect_by_cond(., ToegestaneKetens/Traveldist_Ferry);				
			}
		}
	 	container Fence := PhaseContainer(BlockResultContainer, 'Calculated: '+string(StartCalc/BlockDomain_name));
	}
	
	container x 
	{
		unit<uint64> Write_Result   := ='union_unit_uint64('+AsItemList('KetenGeneratie_PerBlock/'+impl/BlockDomain/name+'/Fence/Result')+')'
		, StorageName = "=StorageName_Str"
		, Descr = "Deze set bevat de geunionede resultaten per block."
		, using = "impl"
		{
			// for tracing back resulting values
			attribute<impl/BlockDomain>    Block_rel                  := ='union_data(.,'+AsItemList('const('+String(Id(BlockDomain))+'[impl/BlockDomain], KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result)')+')', DisableStorage = "True"; 
			attribute<uint64>              result_rel                 := ='union_data(.,'+AsItemList('ID(KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result)')+')', DisableStorage = "True";  
			attribute<Toegestane_Ketens>   Toegestane_Keten_rel       := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Toegestane_Keten_rel')+')';
			
			// primary results
			attribute<Ct>                  Price                      := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Price')+')';
			attribute<Ct>                  Price_augm                 := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Price_augm')+')';
			attribute<s>                   Traveltime                 := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Traveltime')+')';
			attribute<dam>                 TravelDist_Bus             := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/TravelDist_Bus')+')';
			attribute<dam>                 Traveldist_Metro           := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Traveldist_Metro')+')';
			attribute<dam>                 Traveldist_Tram            := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Traveldist_Tram')+')';
			attribute<dam>                 Traveldist_Rail            := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Traveldist_Rail')+')';
			attribute<dam>                 Traveldist_Ferry           := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/Traveldist_Ferry')+')';
		
			attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel      := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/uq_c_FromTime_Stop_rel')+')';
			attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel        := ='union_data(.,'+AsItemList('KetenGeneratie_PerBlock/'+BlockDomain/name+'/Fence/Result/uq_c_ToTime_Stop_rel')+')';
		} 
	}
	
	unit<uint64> PT
	: StorageName = "=StorageName_Str"
	, StorageReadOnly = "true"
	, using = "impl"
	{ 
		attribute<ct>                   Price;
		attribute<ct>                   Price_augm;
		attribute<s>                    Traveltime;
		attribute<Toegestane_Ketens>    Toegestane_Keten_rel;
	
		attribute<dam>                  TravelDist_Bus;
		attribute<dam>                  Traveldist_Metro;
		attribute<dam>                  Traveldist_Tram;
		attribute<dam>                  Traveldist_Rail;
		attribute<dam>                  Traveldist_Ferry;
	
		attribute<uq_c_FromTime_Stop>   uq_c_FromTime_Stop_rel;
		attribute<uq_c_ToTime_Stop>     uq_c_ToTime_Stop_rel;
		
		attribute<c_Time_Stops>         c_FromTime_Stop_rel      := uq_c_FromTime_Stop_rel->values;
		attribute<c_Time_Stops>         c_ToTime_Stop_rel        := uq_c_ToTime_Stop_rel  ->values;
		
		attribute<Time>                 From_Time_rel            := value(c_FromTime_Stop_rel / uint64(#Stops), Time);
		attribute<Stops>                From_Stop_rel            := value(c_FromTime_Stop_rel % uint64(#Stops), Stops);
		attribute<Time>                 To_Time_rel              := value(c_ToTime_Stop_rel / uint64(#Stops), Time);
		attribute<Stops>                To_Stop_rel              := value(c_ToTime_Stop_rel % uint64(#Stops), Stops); 
	
		attribute<Stops/c_Stop_Stop>    c_Stop_Stop_rel          := combine_data(Stops/c_Stop_Stop, From_Stop_rel, To_Stop_rel);
		attribute<Places>               From_Place_rel           := Stops/Place_rel[From_Stop_rel];
		attribute<Places>               To_Place_rel             := Stops/Place_rel[To_Stop_rel];
		attribute<c_Time_Places>        c_FromTime_Place_rel     := combine_data(c_Time_Places, From_Time_rel, From_Place_rel);
		attribute<c_Time_Places>        c_ToTime_Place_rel       := combine_data(c_Time_Places, To_Time_rel, To_Place_rel);
	}
	
	parameter<string>     StorageName_Str := 
		'%LocalDataProjDir%/IntermediateResults/PT_Ketens_'+Time/TemplatableTextShrt[impl/EersteVertrekMoment]+
		'_to_'+Time/TemplatableTextShrt[impl/LaatsteAankomstMoment]+
		'_'+/ModelParameters/Analysis_date+
		'_min-'+AsList(Classifications/FinalParetoAttr/FileNameElement, '_')+
		'_maxtransf-'+string(ModelParameters/Max_overstappen)+
		'_MaxOV-' + string(ModelParameters/MaxOVTime) + 'min'+
		'.fss';
		
	#include<KetenRijger_T.dms>
	#include<CreateTransfers_T.dms>
	#include<Get_Windowed_Agency_Set_T.dms>
}
