Template Calc_Single_Chain_T
{
	parameter<string> voortransport_network_str;
	unit<uint32>      publictransport_network_unit;
	parameter<string> natransport_network_str;
	///

	unit<uint32> Voortransport0 := ='TimeInvariantConnections/Org2Stops_'+voortransport_network_str+'/Create_Routes/ODMatrix'
	{
		attribute<Places>  FromPlace_rel                      := =IsVoorTransport ? 'rlookup(FromPoint, Places/geometry)' : 'rlookup(ToPoint, Places/geometry)' ;
		attribute<Places>  ToPlace_rel                        := =IsVoorTransport ? 'rlookup(ToPoint, Places/geometry)'   : 'rlookup(FromPoint, Places/geometry)';
	}
	
	unit<uint32> Natransport0 := ='TimeInvariantConnections/Stops2Dest_'+natransport_network_str+'/Create_Routes/ODMatrix'
	{
		attribute<Places>  FromPlace_rel                      := =IsVoorTransport ? 'rlookup(FromPoint, Places/geometry)' : 'rlookup(ToPoint, Places/geometry)' ;
		attribute<Places>  ToPlace_rel                        := =IsVoorTransport ? 'rlookup(ToPoint, Places/geometry)'   : 'rlookup(FromPoint, Places/geometry)';
	}
	
	unit<uint32> Voortransport_prep := join_equal_values_uint32(Voortransport0/ToPlace_rel, NodeSet/Place_rel) 
	, Descr = "We koppelen hier time-invariant routes (bijvoorbeeld loop voortransport) aan time-variant routes (ScheduledSpaceTimeEvents). bijvoorbeeld "
		"lopen org1 naar halte 1 om 9.00u en lopen org1 naar halt 1 om 9.10u. Zo worden deze looproutes efficient gedupliceerd. Sparse omdat niet alle "
		"mogelijke opties worden uitwerkt maar alleen diegene die nodig zijn."
	{
		attribute<string>                      Label             := Voortransport0/Label[OD_rel];
		attribute<Places>                      FromPlace_rel     := Voortransport0/FromPlace_rel[OD_rel];
		attribute<Places>                      ToPlace_rel       := X_rel;
		attribute<Voortransport0>              OD_rel            := first_rel;
		attribute<NodeSet>                     Node_rel          := second_rel;
		attribute<c_Time_Places>               c_Time_Place_rel  := NodeSet/c_Time_Place_rel[Node_rel];
		
		attribute<Time>                        FromTime          := ToTime - Voortransport0/Duration[OD_rel];	//gegeven dat het voortransport is.
		attribute<Time>                        ToTime            := NodeSet/Time_rel[Node_rel];				 	//gegeven dat het voortransport is.
		attribute<s_f>                         Duration_seconds  := Voortransport0/Duration_seconds[OD_rel];
		
		attribute<Modes>                       Mode_rel          := ='const(Modes/v/Walking,.)';
		attribute<Routes>                      Route_rel         := rlookup(const('Org2Stops_'+voortransport_network_str, .), Routes/route_id);
		attribute<rdc>                         geometry (arc)    := Voortransport0/geometry[OD_rel];
		attribute<km>                          LengthKm          := Voortransport0/LengthKm[OD_rel];
		
		attribute<Org>                         Origin_rel        := Voortransport0/StartRef[OD_rel];

		attribute<bool>   IsSub_from := FromTime >= inTime ;
		attribute<bool>   IsSub_to   := ToTime   < (inTime + (convert(ModelParameters/MaxTravelTime, s_f)[Time]));
		attribute<bool>   IsSub_dur  := ='duration_seconds <= convert(ModelParameters/Max'+voortransport_network_str+'Time_Org2Stops, s_f)';
	}

	unit<uint32> Natransport_prep := join_equal_values_uint32(Natransport0/ToPlace_rel, NodeSet/Place_rel) 
	, Descr = "koppel PT-netwerk aan start-place looproute"
	{
		attribute<string>                      Label             := Natransport0/Label[OD_rel];
		attribute<Places>                      FromPlace_rel     := Natransport0/FromPlace_rel[OD_rel];
		attribute<Places>                      ToPlace_rel       := X_rel;
		attribute<Natransport0>                OD_rel            := first_rel;
		attribute<NodeSet>                     Node_rel          := second_rel;
		attribute<c_Time_Places>               c_Time_Place_rel  := NodeSet/c_Time_Place_rel[Node_rel];
		
		attribute<Time>                        FromTime          := NodeSet/Time_rel[Node_rel];				 	//gegeven dat het natransport is.
		attribute<Time>                        ToTime            := FromTime + Natransport0/Duration[OD_rel];	//gegeven dat het natransport is.
		attribute<s_f>                         Duration_seconds  := Natransport0/Duration_seconds[OD_rel];
		
		attribute<Modes>                       Mode_rel          := ='const(Modes/v/Walking,.)';
		attribute<Routes>                      Route_rel         := rlookup(const('Stops2Dest_'+natransport_network_str, .), Routes/route_id);
		attribute<rdc>                         geometry (arc)    := Natransport0/geometry[OD_rel];
		attribute<km>                          LengthKm          := Natransport0/LengthKm[OD_rel];
		
		attribute<Dest>                        Dest_rel          := Natransport0/EindRef[OD_rel];
		
		attribute<bool>   IsSub_from := FromTime >= inTime ;
		attribute<bool>   IsSub_to   := ToTime   < (inTime + (convert(ModelParameters/MaxTravelTime, s_f)[Time]));
		attribute<bool>   IsSub_dur  := ='duration_seconds <= convert(ModelParameters/Max'+voortransport_network_str+'Time_Stops2Dest, s_f)';
	}

	
	unit<uint32> Voortransport        := select_with_attr_by_cond(Voortransport_prep, Voortransport_prep/IsSub_from && Voortransport_prep/IsSub_to && Voortransport_prep/IsSub_dur);
	unit<uint32> Natransport          := select_with_attr_by_cond(Natransport_prep, Natransport_prep/IsSub_from && Natransport_prep/IsSub_to && Natransport_prep/IsSub_dur);

	unit<uint32> PTnet_RelevantWindow := ='select_with_attr_by_cond('+PT_net_str+', PTnet_prep/IsSub_from && PTnet_prep/IsSub_to && PTnet_prep/IsSub_dur)'
	{
		attribute<Places>        FromPlace_rel             := rlookup(FromPoint, Places/geometry);
		attribute<Places>        ToPlace_rel               := rlookup(ToPoint, Places/geometry);
		attribute<c_Time_Places> c_fromTime_Place_rel      := combine_data(c_Time_Places, FromTime, FromPlace_rel);
		attribute<c_Time_Places> c_toTime_Place_rel        := combine_data(c_Time_Places, ToTime, ToPlace_rel);
		
		attribute<NodeSet>       F1                        := rlookup(c_fromTime_Place_rel, NodeSet/c_Time_Place_rel);
		attribute<NodeSet>       F2                        := rlookup(c_toTime_Place_rel, NodeSet/c_Time_Place_rel);
		
		unit<uint32> doubledLinks := union_unit(., .)
		, Descr = "in order to get a set of all time-place events"
		{
			attribute<Time>          Time_rel         := union_data(., fromTime, toTime);
			attribute<rdc>           geometry         := union_data(., fromPoint, toPoint);
			attribute<Places>        Place_rel        := rlookup(geometry, Places/geometry);
			attribute<c_Time_Places> c_Time_Place_rel := combine_data(c_Time_Places, Time_rel, Place_rel);
		}
		
		unit<uint32> NodeSet := unique(doubledLinks/c_Time_Place_rel)
		{
			attribute<c_Time_Places>    c_Time_Place_rel := values;
			attribute<Time>             Time_rel         := value(c_Time_Place_rel / uint64(#Places), Time);
			attribute<Places>           Place_rel        := value(c_Time_Place_rel % uint64(#Places), Places);
			attribute<rdc>              geometry         := Places/geometry[Place_rel];
			attribute<string>           Label            := Places/label[Place_rel] + ' @ ' + Time/Label[Time_rel];
		}
	}
	
	unit<uint32>        NodeSet           := PTnet_RelevantWindow/NodeSet;
	
	unit<uint64> OD_orgzones := 
		impedance_matrix_od64('directed;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);cut(OrgZone_max_imp);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel,LinkSet'
			, PTnet_RelevantWindow/Duration
			, PTnet_RelevantWindow/F1
			, PTnet_RelevantWindow/F2
			
			, Voortransport/Node_rel , Voortransport/Duration_seconds, Voortransport/Origin_rel     //sP node_rel, impedance, OrgZone_rel
			, Natransport/Node_rel, Natransport/Duration_seconds , Natransport/Dest_rel      //eP node_rel, impedance, DstZone_rel
			, convert(ModelParameters/MaxOVTime, s_f)
			, PTnet_RelevantWindow/Length
		)
	{
		attribute<rdc>    geometry (arc) := points2sequence(AfgelegdeReis/relevant_points/point, AfgelegdeReis/relevant_points/reis_rel, AfgelegdeReis/relevant_points/ordinal_new), Descr = "daadwerkelijk afgelegde route geometry";
	
		unit<uint32> AfgelegdeReis := sequence2points(LinkSet) //vertaling van LinkSet attribute (afgelegde route in OD), naar onderdelen van de reis
		{
			attribute<..>                      Reis_rel                := Sequence_rel;
			attribute<rdc>                     geometry (arc)          := PTnet_RelevantWindow/geometry[point];
			attribute<rdc>                     FromPoint               := PTnet_RelevantWindow/FromPoint[point];
			attribute<rdc>                     ToPoint                 := PTnet_RelevantWindow/ToPoint[point];
			attribute<Places>                  FromPlace_rel           := PTnet_RelevantWindow/FromPlace_rel[point];
			attribute<Places>                  ToPlace_rel             := PTnet_RelevantWindow/ToPlace_rel[point];
			attribute<Time>                    FromTime                := PTnet_RelevantWindow/FromTime[point];
			attribute<Time>                    ToTime                  := PTnet_RelevantWindow/ToTime[point];
			attribute<Modes>                   Mode_rel                := PTnet_RelevantWindow/Mode_rel[point];
			attribute<min_f>                   reistijd_min            := ../impedance[reis_rel][min_f];
			attribute<LinkTypes>               LinkType_rel            := PTnet_RelevantWindow/LinkType_rel[point];
			attribute<Agencies>                Agency_rel              := PTnet_RelevantWindow/Agency_rel[point];
			attribute<Stops>                   FromStop_rel            := Places/Stop_rel[FromPlace_rel];
			attribute<Stops>                   ToStop_rel              := Places/Stop_rel[ToPlace_rel];
			attribute<Routes>                  Route_rel               := PTnet_RelevantWindow/Route_rel[point];
			attribute<upoint>                  Reis_Route_Identifier   := point_xy(Route_rel, uint32(Reis_rel));
			attribute<uq_reis_route>           uq_reis_route_rel       := rlookup(Reis_Route_Identifier, uq_reis_route/values);
			attribute<uint64>                  Reis_FromTime_Identifier := Reis_rel * value(1000000000, uint64) + value(FromTime, uint64);
			attribute<uint64>                  Reis_ToTime_Identifier   := Reis_rel * value(1000000000, uint64) + value(ToTime, uint64);
			
			unit<uint32> seq2point   := sequence2points(geometry) //in omgekeerde volgorde
			{
				attribute<AfgelegdeReis> subreis_rel          := sequence_rel;
				attribute<...>           reis_rel             := ../reis_rel[subreis_rel];
			}
			
			unit<uint32> relevant_points := select_with_attr_by_cond(seq2point, seq2point/ordinal == 0)
			, Descr = "nodig om full trip geometry te bepalen."
			{
				attribute<uint32>        unity                := const(1,.);
				attribute<uint32>        ordinal_src          := cumulate(unity, reis_rel) - 1;
				attribute<uint32>        max_ordinal_per_reis := max(ordinal_src, reis_rel)[reis_rel];
				attribute<uint32>        ordinal_new          := max_ordinal_per_reis - ordinal_src, Descr = "de ordinal uit de linkset is in gekeerde volgorde, dus moet omgedraaid worden.";
			}
	
			unit<uint32> uq_reis_route := unique(Reis_Route_Identifier) 
			, Descr = "indikking van reis/route combinaties. Transfers en wachten vallen eruit, net zoals de tussenliggende stations binnen een route."
			{
				attribute<Routes>        Route_rel                     := pointcol(values);
				attribute<...>           Reis_rel                      := value(pointrow(values),...);
				attribute<Agencies>      Agency_rel                    := first(../Agency_rel, ../uq_reis_route_rel);
				attribute<Modes>         Mode_rel                      := first(../Mode_rel, ../uq_reis_route_rel);
				attribute<Time>          First_StopTime_Route          := min(../FromTime, ../uq_reis_route_rel);
				attribute<Time>          Last_StopTime_Route           := max(../ToTime, ../uq_reis_route_rel);
				attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
				// attribute<km>            Afgelegde_afstand_OV          := sum(../Length_OV, ../uq_reis_route_rel); //nodig tbv variabele prijs bepaling
				attribute<.>             Reis_Time_Sort_Index          := index(Reis_FirstTime_Identifier);
			}
			
			unit<uint32> uq_reis_route_sorted := unique(uq_reis_route/Reis_Time_Sort_Index) 
			, Descr = "hack om het domein te sorteren op reis_rel en vertrektijden. Om zo in de prijsbepaling de volgende 'leg' te kunnen bepalen. En dus bus/trein onderbroken door overstappen samen te kunnen voegen."
			{
				attribute<Routes>        Route_rel                     := (uq_reis_route/Route_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<...>           Reis_rel                      := (uq_reis_route/Reis_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<Agencies>      Agency_rel                    := (uq_reis_route/Agency_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				
				attribute<Time>          First_StopTime_Route          := (uq_reis_route/First_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<Time>          Last_StopTime_Route           := (uq_reis_route/Last_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
				// attribute<km>            Afgelegde_afstand_OV          := (uq_reis_route/Afgelegde_afstand_OV[uq_reis_route/Reis_Time_Sort_Index])[values];
				
				attribute<Stops>         FromStop_rel                  := rjoin(impl/Reis_FirstTime_Identifier, ../Reis_FromTime_Identifier, ../FromStop_rel);
				attribute<Stops>         ToStop_rel                    := rjoin(impl/Reis_LastTime_Identifier, ../Reis_ToTime_Identifier, ../ToStop_rel);
				
				unit<uint32> impl := uq_reis_route_sorted
				{
					attribute<Modes>         Mode_rel                      := (uq_reis_route/Mode_rel[uq_reis_route/Reis_Time_Sort_Index])[values];

					attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
					attribute<uint64>        Reis_LastTime_Identifier      := uint64(Reis_rel) * value(1000000000, uint64) + value(Last_StopTime_Route, uint64);
					attribute<string>        RouteName_short               := Routes/route_short_name[Route_rel];
				}
			}
			
			unit<uint32> VisualisatieTabel_AfgelegdeReis := uq_reis_route_sorted
			{
				attribute<...>           Reis_rel                      := uq_reis_route_sorted/Reis_rel;
				attribute<Modes>         Mode_rel                      := uq_reis_route_sorted/impl/Mode_rel;
				attribute<Agencies>      Agency_rel                    := uq_reis_route_sorted/Agency_rel;
				attribute<string>        RouteName                     := uq_reis_route_sorted/impl/RouteName_short;

				attribute<Time>          First_StopTime_Route          := uq_reis_route_sorted/First_StopTime_Route;
				attribute<Stops>         FromStop_rel                  := uq_reis_route_sorted/FromStop_rel;
				attribute<Time>          Last_StopTime_Route           := uq_reis_route_sorted/Last_StopTime_Route;
				attribute<Stops>         ToStop_rel                    := uq_reis_route_sorted/ToStop_rel;
				attribute<min_f>         Reistijd                      := convert(float32((Last_StopTime_Route - First_StopTime_Route) /  1[Time]) * 1[s_f], min_f);
				// attribute<Euro>          Price                         := uq_reis_route_sorted/Price;
				// attribute<km>            Afgelegde_afstand_OV          := uq_reis_route_sorted/Afgelegde_afstand_OV;
				
				attribute<rdc>           geometry        (arc, ..) := ../geometry, Descr = "daadwerkelijk afgelegde route geometry";
			}
		}
	}
}
