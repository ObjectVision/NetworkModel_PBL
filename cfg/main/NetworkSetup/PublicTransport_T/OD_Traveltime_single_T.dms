Template OD_Traveltime_single_T   //26332
{
	parameter<string> voortransport;
	parameter<string> natransport;
	////
	
	parameter<string> name := voortransport+'_OV_'+natransport;
	
	// container Org2Stop     := ='TransitionTypes/Org2Stop_'+voortransport;
	// container Stop2Dest     := ='TransitionTypes/Stop2Dest_'+natransport;
	container Org2Stop      := ='TimeInvariantConnections/Org2Stop_'+voortransport+'/Sparse_uitwerking/AB';
	container Stop2Dest     := ='TimeInvariantConnections/Stop2Dest_'+natransport+'/Sparse_uitwerking/AB';
	
	unit<uint64> OD_src := 
		impedance_matrix_od64('directed;startPoint(Node_rel,impedance,OrgZone_rel);endPoint(Node_rel,impedance,DstZone_rel);cut(OrgZone_max_imp);alternative(link_imp):alt_imp;od:impedance,OrgZone_rel,DstZone_rel,LinkSet'
			, PTnet_subset/Duration
			, PTnet_subset/F1
			, PTnet_subset/F2
			
			, Org2Stop/Transition/NodeRef_O2S , value(Org2Stop/Transition/Duration_withWaitingAtOrg,s_f), Org2Stop/Transition/Origin_rel     //sP node_rel, impedance, OrgZone_rel
			, Stop2Dest/Transition/NodeRef_S2D, value(Stop2Dest/Transition/Duration,s_f)                , Stop2Dest/Transition/Dest_rel //eP node_rel, impedance, DstZone_rel
			, convert(ModelParameters/MaxOVTime, s_f)
			, PTnet_subset/Length
		)
	{
		attribute<Combine_OrgDest>  OD_nummer                                       := combine_data(Combine_OrgDest, OrgZone_rel, DstZone_rel);
		attribute<Euro>             Prijs_per_reis                                  := sum(
																							AfgelegdeReis/uq_reis_route_sorted/Price
																							, AfgelegdeReis/uq_reis_route_sorted/Reis_rel
																						);
		attribute<bool>             IsUnwantedTrip1                                 := all(AfgelegdeReis/Mode_rel == Modes/v/Walking || AfgelegdeReis/Mode_rel == Modes/v/Waiting || AfgelegdeReis/LinkType == LinkTypes/V/Transfer, AfgelegdeReis/Reis_rel);
		attribute<bool>             IsUnwantedTrip2                                 := Sum_Reistijd_VoorNaTransport == impedance;
		attribute<bool>             IsUnwantedTrip                                  := IsUnwantedTrip1 || IsUnwantedTrip2;

		attribute<s_f>              Sum_Reistijd_VoorNaTransport                    := sum(AfgelegdeReis/Reistijd_Voortransport + AfgelegdeReis/Reistijd_Natransport, AfgelegdeReis/Reis_rel);
		attribute<min_f>            reistijd_min                                    := impedance[min_f];
		// attribute<OD_src_uint32>    OD_src_uint32_rel                               := invert(OD_src_uint32/OD_src_rel);
		// attribute<rdc>              geometry (arc)                                  := OD_src_uint32/geometry[OD_src_uint32_rel];
		attribute<rdc>    geometry (arc) := points2sequence(AfgelegdeReis/unioned_subreizen/point, AfgelegdeReis/unioned_subreizen/reis_rel, AfgelegdeReis/unioned_subreizen/ordinal), Descr = "daadwerkelijk afgelegde route geometry";
		
		//nodig om full trip geometry te bepalen.
		// unit<uint32> OD_src_uint32 := union_unit_uint32(OD_src)
		// {
			// attribute<OD_src> OD_src_rel     := union_data(., id(OD_src));
			// attribute<rdc>    geometry (arc) := points2sequence(AfgelegdeReis/unioned_subreizen/point, AfgelegdeReis/unioned_subreizen/OD_src_uint32_rel, AfgelegdeReis/unioned_subreizen/ordinal);
		// }
		
		unit<uint32> AfgelegdeReis := sequence2points(LinkSet) //vertaling van LinkSet attribute (afgelegde route in OD), naar onderdelen van de reis
		{
			unit<uint32> seq2point_voor := sequence2points(geometry_voortransport) //correcte volgorde
			{
				attribute<AfgelegdeReis> subreis_rel          := sequence_rel;
				attribute<OD_src>        reis_rel             := ../reis_rel[subreis_rel];
				// attribute<OD_src_uint32> OD_src_uint32_rel    := ../OD_src_uint32_rel[subreis_rel];
			}
			unit<uint32> seq2point_OV   := sequence2points(geometry) //omgekeerde volgorde
			{
				attribute<AfgelegdeReis> subreis_rel          := sequence_rel;
				attribute<OD_src>        reis_rel             := ../reis_rel[subreis_rel];
				// attribute<OD_src_uint32> OD_src_uint32_rel    := ../OD_src_uint32_rel[subreis_rel];
				attribute<Time>          FromTime             := ../FromTime[subreis_rel];
				attribute<Time>          ToTime               := ../ToTime[subreis_rel];
				attribute<bool>          IsLowestSeqOfReis    := first(sequence_rel, reis_rel)[reis_rel] == Sequence_rel;
				
				unit<uint32> relevant_points := select_with_attr_by_cond(., ordinal == 0);
			}
			unit<uint32> seq2point_na   := sequence2points(geometry_natransport) //correcte volgorde
			{
				attribute<AfgelegdeReis> subreis_rel          := sequence_rel;
				attribute<OD_src>        reis_rel             := ../reis_rel[subreis_rel];
				// attribute<OD_src_uint32> OD_src_uint32_rel    := ../OD_src_uint32_rel[subreis_rel];
			}
			
			//nodig om full trip geometry te bepalen.
			unit<uint32> unioned_subreizen := union_unit(seq2point_voor, seq2point_OV/relevant_points, seq2point_na)
			{
				attribute<rdc>           point                := union_data(., seq2point_voor/point, seq2point_OV/relevant_points/point, seq2point_na/point);
				attribute<AfgelegdeReis> subreis_rel          := union_data(., seq2point_voor/subreis_rel, seq2point_OV/relevant_points/subreis_rel, seq2point_na/subreis_rel);
				attribute<OD_src>        reis_rel             := union_data(., seq2point_voor/reis_rel, seq2point_OV/relevant_points/reis_rel, seq2point_na/reis_rel);
				// attribute<OD_src_uint32> OD_src_uint32_rel    := union_data(., seq2point_voor/OD_src_uint32_rel, seq2point_OV/relevant_points/OD_src_uint32_rel, seq2point_na/OD_src_uint32_rel);
				attribute<uint32>        unity                := const(1,.);
				attribute<bool>          IsOV                 := union_data(., const(FALSE, seq2point_voor), const(TRUE, seq2point_OV/relevant_points), const(FALSE, seq2point_na));
				attribute<uint32>        ordinal_src          := cumulate(unity, reis_rel) - 1;
				attribute<uint32>        max_ordinal_per_reis := max(ordinal_src, reis_rel)[reis_rel];
				attribute<uint32>        ordinal              := IsOV ? max_ordinal_per_reis - ordinal_src : ordinal_src;
			}
			
			attribute<Combine_OrgDest>         OD_nummer               := ../OD_nummer[reis_rel];
			attribute<rdc>                     geometry (arc)          := StaticNet_subset/geometry[point];
			attribute<Places>                  FromPlace               := StaticNet_subset/FromPlace[point];
			attribute<Places>                  ToPlace                 := StaticNet_subset/ToPlace[point];
			attribute<Time>                    FromTime                := StaticNet_subset/FromTime[point];
			attribute<Time>                    ToTime                  := StaticNet_subset/ToTime[point];
			attribute<Modes>                   Mode_rel                := StaticNet_subset/Mode_rel[point];
			attribute<min_f>                   reistijd_min            := ../impedance[reis_rel][min_f];
			
			attribute<LinkTypes>               LinkType                := StaticNet_subset/LinkType[point];
			attribute<km>                      Length_OV               := StaticNet_subset/Length[point]; //nodig tbv variabele prijs bepaling
			attribute<km>                      Total_Length            := AfgelegdeAfstand_Voortransport + Length_OV + AfgelegdeAfstand_Natransport;
			attribute<Agencies>                Agency_rel              := StaticNet_subset/Agency_rel[point];
			
			attribute<Stops>                   FromStop_rel            := Places/Stop_rel[FromPlace];
			attribute<Stops>                   ToStop_rel              := Places/Stop_rel[ToPlace];
			
			attribute<..>                      Reis_rel                := Sequence_rel;
			// attribute<OD_src_uint32>           OD_src_uint32_rel       := ../OD_src_uint32_rel[Sequence_rel];
			attribute<Routes>                  Route_rel               := StaticNet_subset/Route_rel[point];
			attribute<upoint>                  Reis_Route_Identifier   := point_xy(Route_rel, uint32(Reis_rel));
			attribute<uq_reis_route>           uq_reis_route_rel       := rlookup(Reis_Route_Identifier, uq_reis_route/values);
			
			attribute<uint64>                  Reis_FromTime_Identifier := Reis_rel * value(1000000000, uint64) + value(FromTime, uint64);
			attribute<uint64>                  Reis_ToTime_Identifier   := Reis_rel * value(1000000000, uint64) + value(ToTime, uint64);
			
			attribute<rdc>                     geometry_voortransport   (arc) := rjoin(OpstapHalte, Org2Stop/Transition/Place_rel, Org2Stop/Transition/geometry);
			attribute<Places>                  OpstapHalte                    := min(FromTime, reis_rel)[reis_rel] == FromTime ? FromPlace : null_u; //tbv afgelegde afstand voortransport
			attribute<km>                      AfgelegdeAfstand_Voortransport := MakeDefined(rjoin(OpstapHalte, Org2Stop/Transition/Place_rel, Org2Stop/Transition/LengthKm), 0[km]);
			attribute<s_F>                     Reistijd_Voortransport         := MakeDefined(rjoin(OpstapHalte, Org2Stop/Transition/Place_rel, Org2Stop/Transition/Duration[s_f]), 0[s_f]);
			
			attribute<rdc>                     geometry_natransport     (arc) := rjoin(UitstapHalte, Stop2Dest/Transition/Place_rel, Stop2Dest/Transition/geometry);
			attribute<Places>                  UitstapHalte                   := max(ToTime, reis_rel)[reis_rel] == ToTime ? ToPlace : null_u; //; //tbv afgelegde afstand natransport
			attribute<km>                      AfgelegdeAfstand_Natransport   := MakeDefined(rjoin(UitstapHalte, Stop2Dest/Transition/Place_rel, Stop2Dest/Transition/LengthKm), 0[km]);
			attribute<s_F>                     Reistijd_Natransport           := MakeDefined(rjoin(UitstapHalte, Stop2Dest/Transition/Place_rel, Stop2Dest/Transition/Duration[s_f]), 0[s_f]);
			
			attribute<bool>                    IsUnwantedTrip                 := ../IsUnwantedTrip[reis_rel];
			
			unit<uint32> uq_reis_route := unique(Reis_Route_Identifier) //indikking van reis/route combinaties. Transfers en wachten vallen eruit, net zoals de tussenliggende stations binnen een route.
			// , KeepData = "true"
			{
				attribute<Routes>        Route_rel                     := pointcol(values);
				attribute<...>           Reis_rel                      := value(pointrow(values),...);
				attribute<Agencies>      Agency_rel                    := first(../Agency_rel, ../uq_reis_route_rel);
				attribute<Modes>         Mode_rel                      := first(../Mode_rel, ../uq_reis_route_rel);
				attribute<Time>          First_StopTime_Route          := min(../FromTime, ../uq_reis_route_rel);
				attribute<Time>          Last_StopTime_Route           := max(../ToTime, ../uq_reis_route_rel);
				attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
				attribute<km>            Afgelegde_afstand_OV          := sum(../Length_OV, ../uq_reis_route_rel); //nodig tbv variabele prijs bepaling
				attribute<.>             Reis_Time_Sort_Index          := index(Reis_FirstTime_Identifier);
			}
			
			unit<uint32> uq_reis_route_sorted := unique(uq_reis_route/Reis_Time_Sort_Index) // hack om het domein te sorteren op reis_rel en vertrektijden. Om zo in de prijsbepaling de volgende 'leg' te kunnen bepalen. En dus bus/trein onderbroken door overstappen samen te kunnen voegen.
			{
				attribute<Routes>        Route_rel                     := (uq_reis_route/Route_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<...>           Reis_rel                      := (uq_reis_route/Reis_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<Agencies>      Agency_rel                    := (uq_reis_route/Agency_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
				
				attribute<Time>          First_StopTime_Route          := (uq_reis_route/First_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<Time>          Last_StopTime_Route           := (uq_reis_route/Last_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
				attribute<km>            Afgelegde_afstand_OV          := (uq_reis_route/Afgelegde_afstand_OV[uq_reis_route/Reis_Time_Sort_Index])[values];
				
				attribute<Stops>         FromStop_rel                  := rjoin(impl/Reis_FirstTime_Identifier, ../Reis_FromTime_Identifier, ../FromStop_rel);
				attribute<Stops>         ToStop_rel                    := rjoin(impl/Reis_LastTime_Identifier, ../Reis_ToTime_Identifier, ../ToStop_rel);
				
				attribute<bool>          NS_Station_Prijs_IntegrityCheck := Agency_rel == Agencies/V/NS ? IsDefined(impl/NS_OrgDest_identifier) : TRUE;
				// attribute<bool>          Prijs_IntegrityCheck            := Agencies/IsForeign[Agency_rel] || IsDefined(impl/PrijsTabel_rel);
				attribute<bool>          Prijs_IntegrityCheck            := IsDefined(impl/PrijsTabel_rel);
				
				attribute<Euro>          Price                         := Agency_rel == Agencies/V/NS  //NS (en andere rail) is anders, want die gaat op totale NS reis uit een afstandstabel
																			|| Agency_rel == Agencies/V/NS_International
																			|| Agency_rel == Agencies/V/DB 
																			|| Agency_rel == Agencies/V/Eu_sleeper
																			|| Agency_rel == Agencies/V/Eurobahn
																				? impl/IsPrevLegSameAgency
																					? 0[Euro]	// in dat geval is het al in die 'leg' berekend
																					: rjoin(impl/NS_OrgDest_identifier
																							, SourceData/Infrastructuur/OVprijzen/NS/NS_tariefeenheden_matrix/ConnectedNetwork/ODMatrix/OrgDest_identifier
																							, SourceData/Infrastructuur/OVprijzen/NS/NS_tariefeenheden_matrix/ConnectedNetwork/ODMatrix/Prijs)
																				: impl/IsPrevLegSameAgency //
																					?                                               PrijsTabel/VariabelePrijs[impl/PrijsTabel_rel] * Afgelegde_afstand_OV //instaptarief al in vorige leg geteld, dus enkel variabele deel
																					: PrijsTabel/VastePrijs[impl/PrijsTabel_rel] + (PrijsTabel/VariabelePrijs[impl/PrijsTabel_rel] * Afgelegde_afstand_OV) //instaptarief plus variabele deel
																			, IntegrityCheck = "all(NS_Station_Prijs_IntegrityCheck) && all(Prijs_IntegrityCheck)";
				
				unit<uint32> impl := uq_reis_route_sorted
				{
					attribute<Modes>         Mode_rel                      := (uq_reis_route/Mode_rel[uq_reis_route/Reis_Time_Sort_Index])[values];

					attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
					attribute<uint64>        Reis_LastTime_Identifier      := uint64(Reis_rel) * value(1000000000, uint64) + value(Last_StopTime_Route, uint64);
					attribute<string>        RouteName_short               := Routes/route_short_name[Route_rel];
					
					attribute<bool>          IsNextLegSameAgency           := reis_rel == reis_rel[add_or_null(id(.),1[.])] && agency_rel == agency_rel[add_or_null(id(.),1[.])];
					attribute<bool>          IsPrevLegSameAgency           := reis_rel == reis_rel[sub_or_null(id(.),1[.])] && agency_rel == agency_rel[sub_or_null(id(.),1[.])];

					attribute<string>        Mode_Agency_CG_Lijn_identifier := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel] + '_' + RouteName_short;
					attribute<string>        Mode_Agency_CG_identifier      := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel];
					attribute<string>        Mode_Agency_identifier         := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel];
				
					attribute<NS_Stations>   From_NS_Stations_rel          := Stops/NS_Stations_rel[FromStop_rel];
																					
					attribute<NS_Stations>   To_NS_Stations_rel_IfNextSame    := Stops/NS_Stations_rel[ToStop_rel[add_or_null(id(.),1[.])]];
					attribute<NS_Stations>   To_NS_Stations_rel_IfNotNextSame := Stops/NS_Stations_rel[ToStop_rel];
					
					attribute<NS_Stations>   To_NS_Stations_rel            := IsNextLegSameAgency 
																					? Stops/NS_Stations_rel[ToStop_rel[add_or_null(id(.),1[.])]]
																					: Stops/NS_Stations_rel[ToStop_rel];
					attribute<upoint>        NS_OrgDest_identifier         := point_xy(From_NS_Stations_rel, To_NS_Stations_rel, upoint);

					attribute<PrijsTabel>    PrijsTabel_rel_initial        := rlookup(Mode_Agency_CG_Lijn_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented1     := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented2     := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
					attribute<PrijsTabel>    PrijsTabel_rel_augmentation   := MakeDefined(PrijsTabel_rel_augmented1, PrijsTabel_rel_augmented2);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev1 := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_identifier);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev2 := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_identifier);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev  := MakeDefined(PrijsTabel_rel_augmented_rev1, PrijsTabel_rel_augmented_rev2);
					attribute<PrijsTabel>    PrijsTabel_rel_augmented      := MakeDefined(PrijsTabel_rel_augmentation, PrijsTabel_rel_augmented_rev);
					attribute<PrijsTabel>    PrijsTabel_rel                := MakeDefined(PrijsTabel_rel_initial, PrijsTabel_rel_augmented);
				
					// attribute<Provincie>       Start_Provincie_rel           := point_in_polygon(Stops/geometry[FromStop_rel], Provincie/geometry);
					attribute<Concessiegebied> Start_Concessiegebied_rel     := point_in_polygon(Stops/geometry[FromStop_rel], Concessiegebied/geometry);
				}
			}
			
			unit<uint32> VisualisatieTabel_AfgelegdeReis := uq_reis_route_sorted
			{
				attribute<...>           Reis_rel                      := uq_reis_route_sorted/Reis_rel;
				attribute<Modes>         Mode_rel                      := uq_reis_route_sorted/impl/Mode_rel;
				attribute<Agencies>      Agency_rel                    := uq_reis_route_sorted/Agency_rel;
				attribute<string>        RouteName                     := uq_reis_route_sorted/impl/RouteName_short;

				attribute<Time>          First_StopTime_Route          := uq_reis_route_sorted/First_StopTime_Route;
				attribute<Stops>         FromStop_rel                  := uq_reis_route_sorted/FromStop_rel;
				attribute<Time>          Last_StopTime_Route           := uq_reis_route_sorted/Last_StopTime_Route;
				attribute<Stops>         ToStop_rel                    := uq_reis_route_sorted/ToStop_rel;
				attribute<min_f>         Reistijd                      := convert(float32((Last_StopTime_Route - First_StopTime_Route) /  1[Time]) * 1[s_f], min_f);
				attribute<Euro>          Price                         := uq_reis_route_sorted/Price;
				attribute<km>            Afgelegde_afstand_OV          := uq_reis_route_sorted/Afgelegde_afstand_OV;
				
				attribute<rdc>           geometry        (arc, OD_src) := OD_src/geometry, Descr = "daadwerkelijk afgelegde route geometry";
				
			}
			
			// voor visuaisatie
			attribute<rdc>         Route (arc) := points2sequence(LinkPoints/Point, LinkPoints/Sequence_rel, LinkPoints/Ordinal);
			attribute<rdc>         FromPoint   := StaticNet_subset/FromPoint[point];
			attribute<rdc>         ToPoint     := StaticNet_subset/ToPoint[point];

			unit<uint32> LinkPoints := union_unit(., .)
			{
				attribute<rdc>                  Point        := union_data(., FromPoint, ToPoint);
				attribute<..>                   Sequence_rel := union_data(., id(..), id(..));
				attribute<uint32>               Ordinal      := union_data(., const(0,..,uint32), const(1,..,uint32));
			}
		}
	}
	
	// unit<uint64> OD_raw := =ModelParameters/Add_OV_PriceInformation ? 'OD_wPrijzen' : 'OD_woPrijzen';
	unit<uint64> OD     := select(NOT(OD_src/IsUnwantedTrip))
	{
		attribute<rdc>              geometry (arc)                                  := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/geometry);
		attribute<s_f>              impedance                                       := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/impedance);
		attribute<km>               alt_imp                                         := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/alt_imp);
		attribute<Org>              OrgZone_rel                                     := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/OrgZone_rel);
		attribute<Dest>             DstZone_rel                                     := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/DstZone_rel);
		attribute<Euro>             Prijs_per_reis                                  := collect_by_cond(., NOT(OD_src/IsUnwantedTrip), OD_src/Prijs_per_reis);
		attribute<min_f>            reistijd_min                                    := impedance[min_f];
		attribute<km>               afgelegde_afstand_km                            := alt_imp;
		attribute<Combine_OrgDest>  OD_nummer                                       := combine_data(Combine_OrgDest, OrgZone_rel, DstZone_rel);
		
		attribute<float32>          nr_items_of_interest                            := dest/nr_items_of_interest[float32][DstZone_rel];
		attribute<float32>          decay_function                                  := reistijd_min == 0f ? 1f : 1f / (1f + exp(ModelParameters/Advanced/Distance_decay/ov_a + ModelParameters/Advanced/Distance_decay/ov_b*log(reistijd_min / 1[min_f]) + ModelParameters/Advanced/Distance_decay/ov_c*reistijd_min / 1[min_f]));
		attribute<float32>          nr_items_of_interest_decayed                    := MakeDefined(nr_items_of_interest * decay_function,0f);
		attribute<float32>          nr_items_of_interest_bereikbaar_decayed (Org)   := sum(UniqueOD/Best_nr_items_of_interest_decayed, value(UniqueOD/OD_nummer / uint64(#dest), org));
		attribute<float32>          nr_items_of_interest_bereikbaar (Org)           := sum(UniqueOD/Best_nr_items_of_interest, value(UniqueOD/OD_nummer / uint64(#dest), org));

		parameter<string>           MaxDuration_Org2Stop_str                        := string(Org2Stop/ModeMax_min) + 'min';
		parameter<string>           MaxDuration_Stop2Dest_str                       := string(Stop2Dest/ModeMax_min) + 'min';
		attribute<string>           ModeUsed                                        := const(name,.);
		
		attribute<string>           Org_name                                        := org/name[OrgZone_rel];
		attribute<string>           Dest_name                                       := dest/label[DstZone_rel];
		
		attribute<string>           OD_Reistijd_key                                 := string(OD_nummer) +'_' + ModeUsed +'_'+ string(reistijd_min);
		
		unit<uint64> UniqueOD := select_with_org_rel(IsDefined(OD_nummer))
		{
			attribute<float32>          Best_nr_items_of_interest_decayed   := ../nr_items_of_interest_decayed[org_rel];
			attribute<float32>          Best_nr_items_of_interest           := ../nr_items_of_interest[org_rel];
			attribute<min_f>            ShortestTraveltime                  := ../reistijd_min[org_rel];
			attribute<km>               Lengte_Snelste_Reis                 := rjoin(OD_Reistijd_key, ../OD_Reistijd_key, ../afgelegde_afstand_km);
			attribute<Euro>             Prijs_van_snelste_reis              := rjoin(OD_Reistijd_key, ../OD_Reistijd_key, ../Prijs_per_reis);
			attribute<string>           ModeUsed                            := ../ModeUsed[org_rel];
			attribute<Combine_OrgDest>  OD_nummer                           := ../OD_nummer[org_rel];
			attribute<Combine_OrgDest>  values                              := OD_nummer;
			attribute<string>           OrgName                             := Org/name[Origin_rel];
			attribute<string>           DestName                            := Dest/name[Dest_rel];
			attribute<org>              Origin_rel                          := value(OD_nummer / uint64(#Dest), org);
			attribute<dest>             Dest_rel                            := value(OD_nummer % uint64(#Dest), Dest);
			
			attribute<string>           OD_Reistijd_key                     := string(OD_nummer) +'_' + ModeUsed +'_'+ string(ShortestTraveltime);
		}
	}
}
