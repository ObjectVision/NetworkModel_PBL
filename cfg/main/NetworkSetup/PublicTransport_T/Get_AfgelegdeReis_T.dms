Template Get_AfgelegdeReis_T
{
	attribute<UInt32> LinkSet (arc,domain);
	unit<uint64>      domain;
	unit<uint32>      PTnet;
	///
	unit<uint32> DecomposeLinkSet := sequence2points(LinkSet) //vertaling van LinkSet attribute (afgelegde route in OD), naar onderdelen van de reis
	{
		attribute<domain>                  Reis_rel                 := Sequence_rel;
		attribute<rdc>                     geometry (arc)           := PTnet/geometry[point];
		attribute<rdc>                     From_Point                := PTnet/From_Point[point];
		attribute<rdc>                     To_Point                  := PTnet/To_Point[point];
		attribute<Places>                  From_Place_rel            := PTnet/From_Place_rel[point];
		attribute<Places>                  To_Place_rel              := PTnet/To_Place_rel[point];
		attribute<Time>                    From_Time_rel             := PTnet/From_Time_rel[point];
		attribute<Time>                    To_Time_rel               := PTnet/To_Time_rel[point];
		attribute<Modes>                   Mode_rel                 := PTnet/Mode_rel[point];
		attribute<min_f>                   reistijd_min             := domain/impedance[reis_rel][min_f];
		attribute<LinkTypes>               LinkType_rel             := PTnet/LinkType_rel[point];
		attribute<Agencies>                Agency_rel               := PTnet/Agency_rel[point];
		attribute<Stops>                   From_Stop_rel             := Places/Stop_rel[From_Place_rel];
		attribute<Stops>                   To_Stop_rel               := Places/Stop_rel[To_Place_rel];
		attribute<Routes>                  Route_rel                := PTnet/Route_rel[point];
		attribute<upoint>                  Reis_Route_Identifier    := point_xy(Route_rel, uint32(Reis_rel));
		attribute<uq_reis_route>           uq_reis_route_rel        := rlookup(Reis_Route_Identifier, uq_reis_route/values);
		attribute<uint64>                  Reis_FromTime_Identifier := Reis_rel * value(1000000000, uint64) + value(From_Time_rel, uint64);
		attribute<uint64>                  Reis_ToTime_Identifier   := Reis_rel * value(1000000000, uint64) + value(To_Time_rel, uint64);
		attribute<km>                      Length_OV                := PTnet/Length[point]; //nodig tbv variabele prijs bepaling
		attribute<bool>                    IsLastReisdeelWaiting    := Mode_rel[max_index(From_Time_rel, Reis_rel)[Reis_rel]] == Modes/V/Waiting; //10606

		unit<uint32> seq2point   := sequence2points(geometry) //in omgekeerde volgorde
		{
			attribute<..>            subreis_rel          := sequence_rel;
			attribute<domain>        reis_rel             := ../reis_rel[subreis_rel];
		}
		
		unit<uint32> relevant_points := select_with_attr_by_cond(seq2point, seq2point/ordinal == 0)
		, Descr = "nodig om full trip geometry te bepalen."
		{
			attribute<uint32>        unity                := const(1,.);
			attribute<uint32>        ordinal_src          := cumulate(unity, reis_rel) - 1;
			attribute<uint32>        max_ordinal_per_reis := max(ordinal_src, reis_rel)[reis_rel];
			attribute<uint32>        ordinal_new          := max_ordinal_per_reis - ordinal_src, Descr = "de ordinal uit de linkset is in gekeerde volgorde, dus moet omgedraaid worden.";
		}
	}
	unit<uint32> uq_reis_route := unique(DecomposeLinkSet/Reis_Route_Identifier) 
	, Descr = "indikking van reis/route combinaties. Transfers en wachten vallen eruit, net zoals de tussenliggende stations binnen een route."
	{
		attribute<Routes>        Route_rel                     := pointcol(values);
		attribute<domain>        Reis_rel                      := value(pointrow(values),domain);
		attribute<Agencies>      Agency_rel                    := first(DecomposeLinkSet/Agency_rel, DecomposeLinkSet/uq_reis_route_rel);
		attribute<Modes>         Mode_rel                      := first(DecomposeLinkSet/Mode_rel, DecomposeLinkSet/uq_reis_route_rel);
		attribute<Time>          First_StopTime_Route          := min(DecomposeLinkSet/From_Time_rel, DecomposeLinkSet/uq_reis_route_rel);
		attribute<Time>          Last_StopTime_Route           := max(DecomposeLinkSet/To_Time_rel, DecomposeLinkSet/uq_reis_route_rel);
		attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
		attribute<km>            Afgelegde_afstand_OV          := sum(DecomposeLinkSet/Length_OV, DecomposeLinkSet/uq_reis_route_rel); //nodig tbv variabele prijs bepaling
		attribute<.>             Reis_Time_Sort_Index          := index(Reis_FirstTime_Identifier);
	}
	
	unit<uint32> uq_reis_route_sorted := unique(uq_reis_route/Reis_Time_Sort_Index) 
	, Descr = "hack om het domein te sorteren op reis_rel en vertrektijden. Om zo in de prijsbepaling de volgende 'leg' te kunnen bepalen. En dus bus/trein onderbroken door overstappen samen te kunnen voegen."
	{
		attribute<Routes>        Route_rel                     := (uq_reis_route/Route_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
		attribute<domain>        Reis_rel                      := (uq_reis_route/Reis_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
		attribute<Agencies>      Agency_rel                    := (uq_reis_route/Agency_rel[uq_reis_route/Reis_Time_Sort_Index])[values];
		
		attribute<Time>          First_StopTime_Route          := (uq_reis_route/First_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
		attribute<Time>          Last_StopTime_Route           := (uq_reis_route/Last_StopTime_Route[uq_reis_route/Reis_Time_Sort_Index])[values];
		attribute<km>            Afgelegde_afstand_OV          := (uq_reis_route/Afgelegde_afstand_OV[uq_reis_route/Reis_Time_Sort_Index])[values];
		
		attribute<Stops>         From_Stop_rel                  := rjoin(impl/Reis_FirstTime_Identifier, DecomposeLinkSet/Reis_FromTime_Identifier, DecomposeLinkSet/From_Stop_rel);
		attribute<Stops>         To_Stop_rel                    := rjoin(impl/Reis_LastTime_Identifier, DecomposeLinkSet/Reis_ToTime_Identifier, DecomposeLinkSet/To_Stop_rel);
		
		attribute<bool>          NS_Station_Prijs_IntegrityCheck := Agency_rel == Agencies/V/NS ? IsDefined(impl/c_NS_start_end_rel) : TRUE;
		// attribute<bool>          Prijs_IntegrityCheck            := Agencies/IsForeign[Agency_rel] || IsDefined(impl/PrijsTabel_rel);
		attribute<bool>          Prijs_IntegrityCheck            := IsDefined(impl/PrijsTabel_rel);
		
		attribute<Euro>          Price                         := Agency_rel == Agencies/V/NS  //NS (en andere rail) is anders, want die gaat op totale NS reis uit een afstandstabel
																	|| Agency_rel == Agencies/V/NS_International
																	|| Agency_rel == Agencies/V/DB 
																	|| Agency_rel == Agencies/V/Eu_sleeper
																	|| Agency_rel == Agencies/V/Eurobahn
																		? impl/IsPrevLegSameAgency
																			? 0[Euro]	// in dat geval is het al in die 'leg' berekend
																			: rjoin(impl/c_NS_start_end_rel
																					, TariefEenhedenMatrix/c_NS_start_end_rel
																					, TariefEenhedenMatrix/Prijs)
																		: impl/IsPrevLegSameAgency //
																			?                                               PrijsTabel/VariabelePrijs[impl/PrijsTabel_rel] * Afgelegde_afstand_OV //instaptarief al in vorige leg geteld, dus enkel variabele deel
																			: PrijsTabel/VastePrijs[impl/PrijsTabel_rel] + (PrijsTabel/VariabelePrijs[impl/PrijsTabel_rel] * Afgelegde_afstand_OV) //instaptarief plus variabele deel
																	, IntegrityCheck = "all(NS_Station_Prijs_IntegrityCheck) && all(Prijs_IntegrityCheck)";
																	
		attribute<Euro>          Price_R_variabel              := PrijsTabel/VariabelePrijs[impl/PrijsTabel_rel] * Afgelegde_afstand_OV, IntegrityCheck = "all(Prijs_IntegrityCheck)";
		
		
		
		
		
		unit<uint32> impl := uq_reis_route_sorted
		{
			attribute<Modes>         Mode_rel                      := (uq_reis_route/Mode_rel[uq_reis_route/Reis_Time_Sort_Index])[values];

			attribute<uint64>        Reis_FirstTime_Identifier     := uint64(Reis_rel) * value(1000000000, uint64) + value(First_StopTime_Route, uint64);
			attribute<uint64>        Reis_LastTime_Identifier      := uint64(Reis_rel) * value(1000000000, uint64) + value(Last_StopTime_Route, uint64);
			attribute<string>        RouteName_short               := Routes/route_short_name[Route_rel];
			
			attribute<bool>          IsNextLegSameAgency           := reis_rel == reis_rel[add_or_null(id(.),1[.])] && agency_rel == agency_rel[add_or_null(id(.),1[.])];
			attribute<bool>          IsPrevLegSameAgency           := reis_rel == reis_rel[sub_or_null(id(.),1[.])] && agency_rel == agency_rel[sub_or_null(id(.),1[.])];

			attribute<string>        Mode_Agency_CG_Lijn_identifier := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel] + '_' + RouteName_short;
			attribute<string>        Mode_Agency_CG_identifier      := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel] +'_'+ Concessiegebied/name[Start_Concessiegebied_rel];
			attribute<string>        Mode_Agency_identifier         := Modes/name[Mode_rel] +'_'+ Agencies/name[Agency_rel];
		
			attribute<NS_Stations>   From_NS_Stations_rel          := Stops/NS_Stations_rel[From_Stop_rel];
																			
			attribute<NS_Stations>   To_NS_Stations_rel_IfNextSame    := Stops/NS_Stations_rel[To_Stop_rel[add_or_null(id(.),1[.])]];
			attribute<NS_Stations>   To_NS_Stations_rel_IfNotNextSame := Stops/NS_Stations_rel[To_Stop_rel];
			
			attribute<NS_Stations>   To_NS_Stations_rel            := IsNextLegSameAgency 
																			? Stops/NS_Stations_rel[To_Stop_rel[add_or_null(id(.),1[.])]]
																			: Stops/NS_Stations_rel[To_Stop_rel];
			// attribute<upoint>        NS_OrgDest_identifier         := point_xy(From_NS_Stations_rel, To_NS_Stations_rel, upoint);
			
			attribute<c_NS_start_end> c_NS_start_end_rel       := combine_data(c_NS_start_end, From_NS_Stations_rel, To_NS_Stations_rel);

			attribute<PrijsTabel>    PrijsTabel_rel_initial        := rlookup(Mode_Agency_CG_Lijn_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented1     := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented2     := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_CG_Lijn_identifier);
			attribute<PrijsTabel>    PrijsTabel_rel_augmentation   := MakeDefined(PrijsTabel_rel_augmented1, PrijsTabel_rel_augmented2);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev1 := rlookup(Mode_Agency_CG_identifier, PrijsTabel/Mode_Agency_CG_identifier);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev2 := rlookup(Mode_Agency_identifier, PrijsTabel/Mode_Agency_identifier);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented_rev  := MakeDefined(PrijsTabel_rel_augmented_rev1, PrijsTabel_rel_augmented_rev2);
			attribute<PrijsTabel>    PrijsTabel_rel_augmented      := MakeDefined(PrijsTabel_rel_augmentation, PrijsTabel_rel_augmented_rev);
			attribute<PrijsTabel>    PrijsTabel_rel                := MakeDefined(PrijsTabel_rel_initial, PrijsTabel_rel_augmented);
		
			// attribute<Provincie>       Start_Provincie_rel           := point_in_polygon(Stops/geometry[FromStop_rel], Provincie/geometry);
			attribute<Concessiegebied> Start_Concessiegebied_rel     := point_in_polygon(Stops/geometry[From_Stop_rel], Concessiegebied/geometry);
			
			
		}
	}
	unit<uint32> VisualisatieTabel := uq_reis_route_sorted
	{
		attribute<domain>        Reis_rel                      := uq_reis_route_sorted/Reis_rel;
		attribute<Modes>         Mode_rel                      := uq_reis_route_sorted/impl/Mode_rel;
		attribute<Agencies>      Agency_rel                    := uq_reis_route_sorted/Agency_rel;
		attribute<string>        RouteName                     := uq_reis_route_sorted/impl/RouteName_short;

		attribute<Time>          First_StopTime_Route          := uq_reis_route_sorted/First_StopTime_Route;
		attribute<Stops>         From_Stop_rel                  := uq_reis_route_sorted/From_Stop_rel;
		attribute<Time>          Last_StopTime_Route           := uq_reis_route_sorted/Last_StopTime_Route;
		attribute<Stops>         To_Stop_rel                    := uq_reis_route_sorted/To_Stop_rel;
		attribute<min_f>         Reistijd                      := convert(float32((Last_StopTime_Route - First_StopTime_Route) /  1[Time]) * 1[s_f], min_f);
		attribute<Euro>          Price                         := uq_reis_route_sorted/Price;
		attribute<km>            Afgelegde_afstand_OV          := uq_reis_route_sorted/Afgelegde_afstand_OV;
		
		attribute<rdc>           geometry        (arc, DecomposeLinkSet) := DecomposeLinkSet/geometry, Descr = "daadwerkelijk afgelegde route geometry";
	}
}






