container Classifications: Using = "Units"
{
	unit<uint32> Transfer_Directions: NrOfRows = 5 
	{
		attribute<string> Label    : ['Top', 'Right', 'Bottom', 'Left', 'Centre'];
		attribute<int16>  row      : [0,1,0,-1,0];
		attribute<int16>  col      : [1,0,-1,0,0];
		attribute<spoint> geometry := point_xy(row, col, spoint);
	}

	unit<uint32> OD_Modes : NrOfRows = 6
	{
		unit<uint32> Matrix := Range(uint32, 0, nrAttr*#.)
		{
			attribute<string> Values: 
			[
			'NS-kort'    , 'Rail'    ,'Nk',
			'NS-lang'    , 'Rail'    ,'Nl',
			'Niet-NS-OV' , ''        ,'R', //een groep waarin het opstaptarief blijft gelden bij overstappen (en je mits 30min overstapt). e.g. 1.08 euro voor bus betalen en daarna 'gratis' op de metro stappen.
			'Transfer'   , 'Walking' ,'T',
			'Walking'    , 'Walking' ,'W',
			'Cycling'    , 'Cycling' ,'C'
			];
		}
		
		// Ketens: https://github.com/ObjectVision/NetworkModel_PBL/issues/31
		
		attribute<string>               Label         := Matrix/Values[value(id(.)* nrAttr + 0, Matrix)];
		attribute<string>               Mode          := Matrix/Values[value(id(.)* nrAttr + 1, Matrix)];
		// attribute<GTFS_Modes/Selectie>  Mode_rel      := rlookup(Mode, GTFS_Modes/Selectie/name);
		attribute<string>               Name          := AsItemName(label);
		
		container V := for_each_nedv(Name, String(ID(.))+'[..]', void, .);
		parameter<uint32> nrAttr := 3;
	}
	
	container Ketens
	{
		parameter<uint32> max_NS_transfers := 3;
		parameter<uint32> max_R_transfers  := 3;
		parameter<uint32> max_OV_ketens    := 2;
		parameter<uint32> max_R_ketens     := 3;
		parameter<uint32> max_overstappen  := 2;
		
		unit<uint32> V := range(0,2), Descr = "voortransport"
		{
			attribute<string> name : ['w', 'c']; 
		}
		unit<uint32> N := range(0,2), Descr = "natransport"
		{
			attribute<string> name : ['w', 'c'];
		}
		
		unit<uint32> V_en_N := combine(V, N) 
		{
			attribute<string> name := V/name[first_rel] + N/name[second_rel]; 
		}
		
		unit<uint32> NS_keten := range(0,max_NS_transfers+2), Descr = "k | l + (l)*"
		{
			attribute<string> name          := id(.) == 0 ? 'k' : repeat('l',id(.));
			attribute<string> left          := strlen(name) == 1 ? name : left(name, strlen(name)-1);
			attribute<string> right         := strlen(name) == 1 ? '' : right(name, 1);
			attribute<string> transfer_name := 'Transfers_'+right(left, 1)+'_'+right;
		}
		unit<uint32> R_keten :=Generate_R_keten_reeks/last;
		
		unit<uint32> OV_keten_range := range(0, max_OV_ketens)
		{
			attribute<string> name      := 'k'+string(id(.));
			attribute<string> prev_name := MakeDefined(name[sub_or_null(id(.),1)]+'/next','Start_Ketens');
		}
		
		unit<uint32> R_keten_range := range(0, max_R_ketens)
		{
			attribute<string> name      := 'r'+string(id(.));
			attribute<string> prev_name := MakeDefined(name[sub_or_null(id(.),1)]+'/Next','Start_R_keten_set');
		}
		
		
		unit<uint32> Start_R_keten_set := range(0, 2)
		{
			attribute<string> name          : ['r', 'o'];
			attribute<string> left          := name;
			attribute<string> right         : ['', ''];
			attribute<string> transfer_name : ['xxx','xxx'];
		}

		
		
		container Generate_R_keten_reeks := 
			for_each_ne(
				R_keten_range/name
				, 'R_keten_T('+R_keten_range/prev_name+')'
			)
		{
			unit<uint32> Last := ='union_unit(Start_R_keten_set, '+AsList(R_keten_range/name+'/Next', ',')+')'
			{
				attribute<string> name          := ='union_data(.,Start_R_keten_set/name, '+AsList(R_keten_range/name+'/Next/name', ',')+')';
				attribute<string> left          := ='union_data(.,Start_R_keten_set/left, '+AsList(R_keten_range/name+'/Next/left', ',')+')';
				attribute<string> right         := ='union_data(.,Start_R_keten_set/right, '+AsList(R_keten_range/name+'/Next/right', ',')+')';
				attribute<string> transfer_name := ='union_data(.,Start_R_keten_set/transfer_name, '+AsList(R_keten_range/name+'/Next/transfer_name', ',')+')';
			}
		}
		
		Template R_keten_T
		{
			unit<uint32> Prev;
			///

			unit<uint32> Next := combine(Prev, Start_R_keten_set), Descr = "*"
			{
				attribute<string> name  :=  Prev/name[first_rel] + Start_R_keten_set/Name[second_rel];
				attribute<string> left  :=  Prev/name[first_rel];
				attribute<string> right :=  Start_R_keten_set/name[second_rel];
				attribute<string> transfer_name := 'Transfers_R_'+right;
			}
		}
		unit<uint32> NS_en_R := combine(NS_Keten, R_Keten) 
		{
			attribute<string> name          := NS_Keten/name[first_rel] + R_keten/name[second_rel]; 
			attribute<string> left          := NS_Keten/name[first_rel];
			attribute<string> right         := R_keten/Name[second_rel];
			attribute<string> transfer_name := 'Transfers_'+right(left, 1)+'_'+left(right, 1);
		}
		unit<uint32> R_en_NS := combine(R_Keten, NS_Keten) 
		{ 
			attribute<string> name          := R_Keten/name[first_rel]+NS_keten/name[second_rel]; 
			attribute<string> left          := R_Keten/name[first_rel];
			attribute<string> right         := NS_keten/Name[second_rel];
			attribute<string> transfer_name := 'Transfers_'+right(left, 1)+'_'+left(right, 1);
		}
		
		container Generate_OV_keten_reeks := 
			for_each_ne(
				OV_keten_range/name
				, 'OV_keten_T('+OV_keten_range/prev_name+')'
			)
		{
			container Last := =last(OV_keten_range/name);
			
			container Start_Ketens
			{
				unit<uint32> leeg := range(0,1)
				{
					attribute<string> name  : [''];
				}
				unit<uint32> NS_first  := NS_en_R;
				unit<uint32> R_first   := R_en_NS;
				// unit<uint32> OV_keten  := leeg;
			}
			
		}
		
		Template OV_keten_T
		{
			container Prev;
			///

			unit<uint32> OV_keten1 := combine(R_keten, Prev/NS_first), Descr = "R-keten + (NS-keten + R-keten)*"
			{
				attribute<string> left  := R_Keten/name[first_rel];
				attribute<string> right := Prev/NS_first/Name[second_rel];
				attribute<string> name  := left + right;
				attribute<string> transfer_name := 'Transfers_R_'+left(right,1);
			}
			unit<uint32> OV_keten2 := combine(OV_keten1, NS_keten), Descr = "R-keten + (NS-keten + R-keten)* + NS-keten"
			{
				attribute<string> left          := OV_keten1/name[first_rel];
				attribute<string> right         := NS_keten/Name[second_rel];
				attribute<string> transfer_name := 'Transfers_R_'+left(right,1);
			}
			unit<uint32> OV_keten3 := combine(NS_keten, Prev/R_first), Descr = "NS-keten + (R-keten + NS-keten)*"
			{
				attribute<string> left          := NS_keten/name[first_rel];
				attribute<string> right         := Prev/R_first/Name[second_rel];
				attribute<string> name          := left + right;
				attribute<string> transfer_name := 'Transfers_'+right(left, 1)+'_'+left(right, 1);
			}
			unit<uint32> OV_keten4 := combine(OV_Keten3, R_Keten), Descr = "NS-keten + (R-keten + NS-keten)* + R-keten"
			{
				attribute<string> left          := OV_Keten3/name[first_rel];
				attribute<string> right         := R_keten/Name[second_rel];
				attribute<string> transfer_name := 'Transfers_'+right(left, 1)+'_'+left(right, 1);
			}
			unit<uint32> OV_keten_unioned := union_unit(OV_keten1,OV_keten2,OV_keten3,OV_keten4), Descr = "1 | 2 | 3 | 4"
			{
				attribute<string> name          := left + right;
				attribute<string> left          := union_data(., OV_keten1/left,OV_keten2/left,OV_keten3/left,OV_keten4/left);
				attribute<string> right         := union_data(., OV_keten1/right,OV_keten2/right,OV_keten3/right,OV_keten4/right);
				attribute<string> transfer_name := union_data(., OV_keten1/transfer_name,OV_keten2/transfer_name,OV_keten3/transfer_name,OV_keten4/transfer_name);
			}
			container Next
			{
				unit<uint32> NS_first := combine(Prev/NS_first, NS_en_R)
				{
					attribute<string> name := Prev/NS_first/name[first_rel] + NS_en_R/name[second_rel];
				}
				unit<uint32> R_first := combine(Prev/R_first, R_en_NS)
				{
					attribute<string> name := Prev/R_first/name[first_rel] + R_en_NS/name[second_rel];
				}
			}
		}
		
		unit<uint32> Multi_OV_keten := ='union_unit(NS_en_R, R_en_NS, '+AsList('Generate_OV_keten_reeks/'+OV_keten_range/name+'/OV_keten_unioned', ',')+')', Descr = ""
		{
			attribute<string> name          := ='union_data(.,NS_en_R/name, R_en_NS/name, '+AsList('Generate_OV_keten_reeks/'+OV_keten_range/name+'/OV_keten_unioned/name', ',')+')';
			attribute<string> left          := ='union_data(.,NS_en_R/left, R_en_NS/left,  '+AsList('Generate_OV_keten_reeks/'+OV_keten_range/name+'/OV_keten_unioned/left', ',')+')';
			attribute<string> right         := ='union_data(.,NS_en_R/right, R_en_NS/right,  '+AsList('Generate_OV_keten_reeks/'+OV_keten_range/name+'/OV_keten_unioned/right', ',')+')';
			attribute<string> transfer_name := ='union_data(.,NS_en_R/transfer_name, R_en_NS/transfer_name,  '+AsList('Generate_OV_keten_reeks/'+OV_keten_range/name+'/OV_keten_unioned/transfer_name', ',')+')';
			
			attribute<uint32> aantal_overstappen := sub_or_null(strlen(name),1);
		}
		
		unit<uint32> OV_Keten := union_unit(NS_keten, R_Keten, Multi_OV_keten), Descr = ""
		{
			attribute<string> name          := union_data(.,NS_keten/name, R_Keten/name, Multi_OV_keten/name);
			attribute<string> left          := union_data(.,NS_keten/left, R_Keten/left, Multi_OV_keten/left);
			attribute<string> right         := union_data(.,NS_keten/right, R_Keten/right, Multi_OV_keten/right);
			attribute<string> transfer_name := union_data(.,NS_keten/transfer_name, R_Keten/transfer_name, Multi_OV_keten/transfer_name);
			
			attribute<uint32> aantal_overstappen := sub_or_null(strlen(name),1);
		}
		
		
		
		unit<uint32> Toegestane_OV_Ketens := select_with_org_rel(OV_Keten/aantal_overstappen <= max_overstappen)
		{
			attribute<string> name          := OV_Keten/name[org_rel];
			attribute<string> left          := OV_Keten/left[org_rel];
			attribute<string> right         := OV_Keten/right[org_rel];
			attribute<string> transfer_name := OV_Keten/transfer_name[org_rel];
		}
	}
	
	
	unit<uint8> TimeInvariantTypes := combine_uint8(TimeInvariant_ConnectionTypes, TimeInvariant_Modes)
	{
		attribute<string> ConnectionType := TimeInvariant_ConnectionTypes/name[first_rel];
		attribute<string> Mode           := TimeInvariant_Modes/Name[second_rel];
		attribute<string> Mode_abbrev    := TimeInvariant_Modes/Name_abbrev[second_rel];
		attribute<string> NetworkType    := TimeInvariant_Modes/NetworkType[second_rel];
		attribute<string> OriginSet      := TimeInvariant_ConnectionTypes/OriginSet[first_rel];
		attribute<string> DestinationSet := TimeInvariant_ConnectionTypes/DestinationSet[first_rel];
		attribute<string> Label          := ConnectionType + '_' + Mode;
		attribute<string> Name           := AsItemName(label);
		attribute<string> Name_short     := ConnectionType + '_' + Mode_abbrev;
		
		container V := for_each_nedv(Name, String(ID(.))+'[..]', void, .);
	}
	
	unit<uint8> TimeInvariant_ConnectionTypes : NrOfRows = 2
	{
		attribute<string> Label          := OriginSet + '2' + DestinationSet;
		attribute<string> OriginSet      : ['Org',  'Stops'];
		attribute<string> DestinationSet : ['Stops', 'Dest'];
		attribute<string> Name           := AsItemName(label);
	}
	unit<uint8> TimeInvariant_Modes : NrOfRows = 2
	{
		attribute<string> Label       : ['Walking', 'Cycling'];
		attribute<string> Name_abbrev : ['W','B'];
		attribute<string> Name        := AsItemName(label);
		attribute<string> NetworkType : ['Pedestrian', 'Bike'];
	}

	#include<modes.dms>
	// #include<lisa.dms>
	#include<osm.dms>
	// #include<LandUse.dms>
	
	unit<uint32> Directions_TomTom : NrOfRows = 4
	{
		attribute<string> code: ['','N','FT','TF'];
		attribute<string> Label: ['dual', 'nocars', 'forwards', 'backwards'];
		
		container V := for_each_nedv(Label, String(ID(.))+'[..]', void, .);
	}
	unit<uint32> Directions_OSM : NrOfRows = 3
	{
		attribute<string> code: ['B','F','T'];
		attribute<string> Label: ['dual', 'forwards', 'backwards'];
		
		container V := for_each_nedv(Label, String(ID(.))+'[..]', void, .);
	}

	unit<uint8> FuncRoadClass_EK := range(uint8, 0b, 9b);
	unit<uint8> FuncRoadClass : nrofrows = 10
	{
		attribute<string> Label : ['Not Applicable', 'Motorway, Freeway, or Other Major Road', 'Major Road Less Important than a Motorway', 'Other Major Road','Secondary Road','Local Connecting Road','Local Road of High Importance','Local Road','Local Road of Minor Importance','Other Road'];
		attribute<string> name := AsItemName(label);
		container V := for_each_nedv(name, String(ID(.))+'[..]', void, .);
	}
	
	unit<uint32> LinkTypes: NrOfRows = 7
	{
		attribute<string> Name     : ['Undefined','Scheduled','Transfer','Stop_to_Dest','Org_to_Stop','Waiting_at_Stop','Waiting_at_Org'];
		attribute<string> Label    := Name;
		attribute<uint32> PenColor : [rgb(128,128,128), rgb(200,0,0), rgb(129,129,0), rgb(0,0,128),rgb(0,0,255), rgb(128,128,128), rgb(128,128,128)], DialogType = "PenColor";
		attribute<int16>  PenStyle : [4,0,1,2,2,0], DialogType = "PenStyle";
		
		container v := for_each_nedv(Name, string(id(.)), void, .);
	}
	
 	unit<uint32> Agencies := unique(lowercase(SourceData/Infrastructuur/GTFS/LoadFeeds/ReadFSS/Agency/data/agency_name))
	{
		attribute<string> name  := AsItemName(values);
		attribute<string> label := values;
		
		attribute<bool>   IsForeign := name == 'de_lijn' || name == 'db'  || name == 'eurobahn' || name == 'niag' || name == 'nmbs' || name == 'vias' || name == 'ns_international' || name == 'eu_sleeper';
						//vervoerders die wel in GTFS zitten maar niet in deze lijst zijn niet opgenomen omdat ze in het buitenland opereren (De Lijn, DB, Eurobahn, NIAG, NMBS, VIAS)
	
		attribute<bool>   IsNS := name == 'ns' || name == 'db'  || name == 'eurobahn' || name == 'ns_international' || name == 'eu_sleeper';
		container V := for_each_nedv(Name, string(id(.)), void, .);
	}
 
	unit<uint8> ImpedanceTypes : nrofrows = 10
	{
		attribute<string> name : ['max_pedestrian','max_bike','max_e_bike','max_car','max_limit_car','congested_morning_car','congested_noon_car','congested_late_car','congested_bike','congested_e_bike'];
	}
	
	unit<uint8> pand_status : nrofrows = 10
	{
		attribute<string>    label     : ['Bouw gestart','Bouwvergunning verleend','Niet gerealiseerd pand','Pand buiten gebruik','Pand gesloopt','Pand in gebruik','Pand in gebruik (niet ingemeten)','Sloopvergunning verleend','Pand ten onrechte opgevoerd','Verbouwing pand'], DialogType = "LabelText";
		attribute<string>    name      := replace(label, ' ', '_', '-', '_', '(', '', ')', '');
		container V := for_each_nedv(name, String(ID(.))+'[..]', void, .);
	}
	
	unit<uint8> vbo_status : nrofrows = 8
	{
		attribute<string>    label     : ['Niet gerealiseerd verblijfsobject','Verblijfsobject buiten gebruik','Verblijfsobject gevormd','Verblijfsobject in gebruik','Verblijfsobject in gebruik (niet ingemeten)','Verblijfsobject ingetrokken','Verblijfsobject ten onrechte opgevoerd', 'Verbouwing verblijfsobject'], DialogType = "LabelText";
		attribute<string>    name      := replace(label, ' ', '_', '-', '_', '(', '', ')', '');
		container V := for_each_nedv(name, String(ID(.))+'[..]', void, .);
	}
	unit<uint8> vbo_gebruiksdoel: nrofrows = 11
	{
		attribute<uint8> ID := ID(.);
		attribute<string> label:
		[
			'bijeenkomstfunctie',
			'celfunctie',
			'gezondheidszorgfunctie',
			'industriefunctie',
			'kantoorfunctie',
			'logiesfunctie',
			'onderwijsfunctie',
			'overige gebruiksfunctie',
			'sportfunctie',
			'winkelfunctie',
			'woonfunctie'
		];
		
		attribute<string> name := replace(replace(label,' ','_'), 'functie','');
		attribute<uint32> BrushColor:  DialogType = "BrushColor",[rgb(255,255,255), rgb(  0,129,  0),rgb(  0,  0,255),rgb(255,220,  0),rgb(255,  0,  0)];
		container V := for_each_nedv(name, String(ID(.))+'[..]', void, .);
	}
	
	unit<uint8> WPSrc: nrofrows = 6
	{
		attribute<string> label :  ['geen woonpand','vrijstaand','twee onder 1 kap','hoekwoning','tussenwoning','appartement'], DialogType = "LabelText";
		attribute<string> name := replace(label, ' ', '_');
		// attribute<WP>  WP_rel :  [0,1,2,3,3,4];
		// attribute<WP3> WP3_rel :  [0,1,1,1,1,2];
		
		container V := for_each_nedv(name, String(ID(.))+'[..]', void, .);
	}
	
}